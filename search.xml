<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot + mybatis 多数据源]]></title>
    <url>%2F2019%2F06%2F05%2Fspringboot%20%2B%20mybatis%20%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[springboot + mybatis 多数据源 参考: https://gitee.com/y_project/RuoYi 简单的把若依项目里面多数据源抽离出来,地址:https://gitee.com/yijiemanong6/springboot-mybatis/tree/master]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat版本错误和mysql设置ONLY_FULL_GROUP_BY]]></title>
    <url>%2F2019%2F05%2F29%2F1%2F</url>
    <content type="text"><![CDATA[An incompatible version [1.2.12] of the APR based Apache Tomcat Native library is installed, while Tomcat requires version [1.2.14]通过实现1+2+3+4+…+n的值学习 CountDownLatch 和 Fork/Join 参考: https://blog.csdn.net/zhoukikoo/article/details/80532483 简单实现方式如下:12// 今天遇到一个错误2019-05-29 18:22:16 | ERROR | main | org.apache.catalina.core.AprLifecycleListener | An incompatible version [1.2.12] of the APR based Apache Tomcat Native library is installed, while Tomcat requires version [1.2.14] 解决方案​ 它说安装了基于APR的Apache Tomcat Native库的不兼容版本[1.2.12]，而Tomcat需要版本[1.2.14],马上百度该问题,找到相关博客,下载该文件后放入C:\Windows\System32中即可,下载地址:http://archive.apache.org/dist/tomcat/tomcat-connectors/native/1.2.14/binaries/ 下载tomcat-native-1.2.14-win32-bin.zip,打开找到bin下x64下tcnative-1.dll放入到C:\Windows\System32中即可,ok,解决问题! ​ 第一个tomcat版本问题已解决,运行项目,继续报错,报错如下: 1which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by ​ 经百度看到这是mysql默认设置了only_full_group_by,在my.ini文件中加入 12#设置sql_mode 很重要 否则初始化好了以后进行查询操作会出现only_full_group_by异常 如果在初始化#的时候没有设置 则需要重新进行初始化sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos; ​ 解决!]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于数组/链表实现LRU缓存]]></title>
    <url>%2F2019%2F05%2F01%2F%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[参考: 数据结构与算法之美 基于数组实现的LRU缓存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package day01;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * 2019/5/1 * 基于数组实现的LRU缓存 * 1. 空间复杂度为O(n) * 2. 时间复杂度为O(n) * 3. 不支持null的缓存 */public class LRUBasedArray&lt;T&gt; &#123; private static int DEFULT_CAPACITY = 1 &lt;&lt; 3; // 数组总容量 private int capacity; // 数组已有数量 private int count; private T[] value; private Map&lt;T,Integer&gt; holder; public LRUBasedArray() &#123; this(DEFULT_CAPACITY); &#125; public LRUBasedArray(int capacity) &#123; this.capacity = capacity; count = 0; value = (T[]) new Object[capacity]; holder = new HashMap&lt;&gt;(capacity); &#125; /** * 模拟访问某个值 */ public void offer(T obj) &#123; if(obj == null) &#123; throw new RuntimeException("不能缓存null"); &#125; Integer integer = holder.get(obj); // 缓存中没有 if (integer == null) &#123; if (isFull()) &#123; // 缓存满了就删除缓存中最后一个并加入到缓存的开头 removeAndCache(obj); &#125; else &#123; // 缓存没满就加入该值 cache(obj,count); &#125; &#125; else &#123; update(integer); &#125; &#125; /** * 缓存中有该值 则更新位置 * @param end */ private void update(int end) &#123; T t = value[end]; rightShift(end); value[0] = t; holder.put(t,0); &#125; /** * 删除缓存中最后一个 并加入到缓存中 */ private void removeAndCache(T obj) &#123; T t = value[--count]; holder.remove(t); cache(obj,count); &#125; /** * 缓存数据到头部，但要先右移 * @param obj * @param end */ private void cache(T obj, int end) &#123; rightShift(end); value[0] = obj; holder.put(obj,0); count++; &#125; /** * 右移 * @param end */ private void rightShift(int end) &#123; for(int i = end - 1; i &gt;= 0; i--) &#123; value[i + 1] = value[i]; holder.put(value[i],i + 1); &#125; &#125; /** * 判断数组是否已经满了 * @return */ private boolean isFull() &#123; return count == capacity; &#125; @Override public String toString() &#123; return "LRUBasedArray&#123;" + "value=" + Arrays.toString(value) + '&#125;'; &#125; static class TestLRUBasedArray &#123; public static void main(String[] args) &#123; testDefaultConstructor(); testSpecifiedConstructor(4); testWithException(); &#125; private static void testWithException() &#123; LRUBasedArray&lt;Integer&gt; lru = new LRUBasedArray&lt;Integer&gt;(); lru.offer(null); &#125; public static void testDefaultConstructor() &#123; System.out.println("======无参测试========"); LRUBasedArray&lt;Integer&gt; lru = new LRUBasedArray&lt;&gt;(); lru.offer(1); lru.offer(2); lru.offer(3); lru.offer(4); lru.offer(5); lru.offer(1); System.out.println(lru); lru.offer(6); lru.offer(7); lru.offer(8); lru.offer(9); System.out.println(lru); &#125; public static void testSpecifiedConstructor(int capacity) &#123; System.out.println("======有参测试========"); LRUBasedArray&lt;Integer&gt; lru = new LRUBasedArray&lt;&gt;(capacity); lru.offer(1); System.out.println(lru); lru.offer(2); System.out.println(lru); lru.offer(3); System.out.println(lru); lru.offer(4); System.out.println(lru); lru.offer(2); System.out.println(lru); lru.offer(4); System.out.println(lru); lru.offer(7); System.out.println(lru); lru.offer(1); System.out.println(lru); lru.offer(2); System.out.println(lru); &#125; &#125;&#125; 基于单链表实现的LRU缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package day01;import java.util.Scanner;/** * 2019/5/1 * 基于单链表LRU算法（java） */public class LREBaseLinkedList&lt;T&gt; &#123; // 默认链表容量 private static final int DEFULT_CAPACITY = 10; // 头结点 private SNode headNode; // 实际链表长度 private Integer length; // 链表容量 private Integer capacity; public LREBaseLinkedList() &#123; this.headNode = new SNode(); this.capacity = DEFULT_CAPACITY; this.length = 0; &#125; public LREBaseLinkedList(Integer capacity) &#123; this.headNode = new SNode(); this.capacity = capacity; this.length = 0; &#125; public void add(T data) &#123; // 获取查找元素的前一个结点 SNode prevNode = findPrevNode(data); if (prevNode != null) &#123; // 删除原数据,添加到链表头部 deleteElemOptim(prevNode); intsertElemAtBegin(data); &#125; else &#123; // 判断链表长度 if(length &gt;= capacity) &#123; // 删除尾部数据 deleteElemAtEnd(); &#125; // 添加新数据到头部 intsertElemAtBegin(data); &#125; &#125; /** * 删除尾部结点 */ private void deleteElemAtEnd() &#123; SNode ptr = headNode; // 空链表直接返回 if(ptr.getNext() == null) &#123; return; &#125; // 获取倒数第二个结点 while (ptr.getNext().getNext() != null) &#123; ptr = ptr.getNext(); &#125; SNode next = ptr.getNext(); ptr.setNext(null); next = null; --length; &#125; private void intsertElemAtBegin(T data) &#123; SNode next = headNode.getNext(); headNode.setNext(new SNode(data,next)); ++length; &#125; /** * 删除prevNode的下一个结点 * @param prevNode */ private void deleteElemOptim(SNode prevNode) &#123; SNode next = prevNode.getNext(); prevNode.setNext(next.getNext()); next = null; --length; &#125; /** * 获取查找元素的前一个结点 * @param data */ private SNode findPrevNode(T data) &#123; SNode node = headNode; while (node.getNext() != null) &#123; if(data.equals(node.getNext().getElement())) &#123; return node; &#125; node = node.getNext(); &#125; return null; &#125; public class SNode &#123; T element; SNode next; public SNode(T element) &#123; this.element = element; &#125; public SNode(T element,SNode next) &#123; this.element = element; this.next = next; &#125; public SNode() &#123; this.next = null; &#125; public T getElement() &#123; return element; &#125; public void setElement(T element) &#123; this.element = element; &#125; public SNode getNext() &#123; return next; &#125; public void setNext(SNode next) &#123; this.next = next; &#125; &#125; public static void main(String[] args) &#123; LREBaseLinkedList&lt;Integer&gt; list = new LREBaseLinkedList&lt;&gt;(); Scanner sc = new Scanner(System.in); while (true) &#123; list.add(sc.nextInt()); list.printAll(); &#125; &#125; private void printAll() &#123; LREBaseLinkedList.SNode node = headNode.getNext(); while (node != null) &#123; System.out.print(node.getElement() + ","); node = node.getNext(); &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过实现1+2+3+4+...+n的值学习 CountDownLatch 和 Fork/Join]]></title>
    <url>%2F2019%2F03%2F16%2F%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B01%2B2%2B3%2B4%2B...%2Bn%E7%9A%84%E5%80%BC%E5%AD%A6%E4%B9%A0-CountDownLatch-%E5%92%8C-ForkJoin%2F</url>
    <content type="text"><![CDATA[好久没写博客了,通过实现1+2+3+4+…+n的值学习 CountDownLatch 和 Fork/Join 参考: https://blog.csdn.net/zl18310999566/article/details/80258329 参考: https://www.cnblogs.com/cjsblog/p/9078341.html 简单实现方式如下:12int i = (n+1) * n / 2;System.out.println(i); ok,上面是简单方式,我们暂且不提,下面来说一下递归来实现以上功能. 递归实现方式如下:123456789public static int sum(int n) &#123; int sum = n; // 递归终止条件，借助&amp;&amp;的短路，对于 A &amp;&amp; B // A=true，执行B // A=false，不执行B // 所以如果 n=0 时，则不会再进行递归调用 boolean isContinue = (n &gt; 0) &amp;&amp; (sum += sum(--n)) &gt; 0; return sum;&#125; 多线程的实现方式CountDownLatch 实现方式如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class CountDownLatchTest &#123; public static void main(String[] args) throws Exception&#123; System.out.println(getSum(1000,3)); &#125; public static class Result&#123; private int sum = 0; public void add(int a)&#123; this.sum += a; &#125; public int getSum()&#123; return this.sum; &#125; &#125; public static int getSum(int end, int threadCount) throws Exception&#123; if(end &lt;= threadCount)&#123; threadCount = end; &#125; Result result = new Result(); CountDownLatch cdl = new CountDownLatch(threadCount); List&lt;MyThread&gt; threadList = new ArrayList&lt;&gt;(threadCount); // new 线程 for(int i = 0;i &lt; threadCount;i++)&#123; threadList.add(new MyThread(result, cdl)); &#125; // 给线程分配任务 for(int i = 0;i &lt; end;i++)&#123; int index = (i + 1) % threadCount; threadList.get(index).addNum(i + 1); &#125; // 启动线程 for(int i = 0;i &lt; threadCount;i++)&#123; threadList.get(i).start(); &#125; cdl.await(); return result.getSum(); &#125; public static class MyThread extends Thread&#123; private List&lt;Integer&gt; numList = new ArrayList&lt;&gt;(); private Result result; private CountDownLatch cdl; public MyThread(Result result, CountDownLatch cdl)&#123; this.result = result; this.cdl = cdl; &#125; public void addNum(int i)&#123; numList.add(i); &#125; public void run() &#123; int sum = 0; for (Integer i : numList) &#123; sum += i; &#125; System.out.println(numList); result.add(sum); cdl.countDown(); &#125; &#125;&#125; Fork/Join 实现方式:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ForkJoinTaskDemo &#123; private class SumTask extends RecursiveTask&lt;Integer&gt; &#123; private static final int THRESHOLD = 20; private int arr[]; private int start; private int end; public SumTask(int[] arr, int start, int end) &#123; this.arr = arr; this.start = start; this.end = end; &#125; /** * 小计 */ private Integer subtotal() &#123; Integer sum = 0; for (int i = start; i &lt; end; i++) &#123; sum += arr[i]; &#125; System.out.println(Thread.currentThread().getName() + ": ∑(" + start + "~" + end + ")=" + sum); return sum; &#125; @Override protected Integer compute() &#123; if ((end - start) &lt;= THRESHOLD) &#123; return subtotal(); &#125;else &#123; int middle = (start + end) / 2; SumTask left = new SumTask(arr, start, middle); SumTask right = new SumTask(arr, middle, end); left.fork(); right.fork(); return left.join() + right.join(); &#125; &#125; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; int[] arr = new int[100]; for (int i = 0; i &lt; 100; i++) &#123; arr[i] = i + 1; &#125; ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; result = pool.submit(new ForkJoinTaskDemo().new SumTask(arr, 0, arr.length)); System.out.println("最终计算结果: " + result.invoke()); pool.shutdown(); &#125;&#125; 此方案具体讲解请参考文章最上方博客,写的很好,极力推荐.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>CountDownLatch</tag>
        <tag>Fork/Join</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 研究]]></title>
    <url>%2F2019%2F03%2F02%2FRabbitMQ%20%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[RabbitMQ 研究介绍 MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。RabbitMQ官方地址：http://www.rabbitmq.com/ 开发中消息队列通常有如下应用场景： 任务异步处理。将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。 应用程序解耦合MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。 为什么使用RabbitMQ ? 使用简单,功能强大 基于AMQP协议 社区活跃,文档完善 高并发性能好,这主要得基于Erlang语言 Spring Boot 默认已集成 RabbitMQ AMQP 是什么 ? AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。—-&lt;百度百科&gt; 总结 : AMQP是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，为的就是解决MQ市场上协议不统一的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务 JMS是什么 ? JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。—–&lt;百度百科&gt; 总结 : JMS是java提供的一套消息服务API标准，其目的是为所有的java应用程序提供统一的消息通信的标准，类似java的jdbc，只要遵循jms标准的应用程序之间都可以进行消息通信。它和AMQP有什么 不同，jms是java语言专属的消息服务标准，它是在api层定义标准，并且只能用于java应用；而AMQP是在协议层定义的标准，是跨语言的 。 快速入门RabbitMQ工作原理 工作模式常用工作模式: Work queues Publish/Subscribe Routing Topics Header Work queues 应用场景: 对于任务过重或任务较多情况使用工作队列模式可以提高任务处理的速度 Publish/subscribe发布订阅模式： 每个消费者监听自己的队列。 生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。 Routing路由模式： 每个消费者监听自己的队列，并且设置routingkey。 生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列。 Topics与上面路由模式类似,可以使用通配符,规则如下: 中间以“.”分隔 符号#可以匹配多个词，符号*可以匹配一个词语 Header模式header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配 Spring整合RabbitMQ 使用spring-boot-starter-amqp会自动添加spring-rabbit依赖，如下： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐test&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐logging&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml 配置连接 RabbitMQ 的参数 1234567891011server: port: 44000spring: application: name: test‐rabbitmq‐producer rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest virtualHost: / 定义RabbitConfig类,配置Exchange, Queue, 及绑定交换机。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xuecheng.test.rabbitmq.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author Administrator * @version 1.0 * @create 2018-06-17 20:45 **/@Configurationpublic class RabbitmqConfig &#123; public static final String QUEUE_INFORM_EMAIL = "queue_inform_email"; public static final String QUEUE_INFORM_SMS = "queue_inform_sms"; public static final String EXCHANGE_TOPICS_INFORM="exchange_topics_inform"; public static final String ROUTINGKEY_EMAIL="inform.#.email.#"; public static final String ROUTINGKEY_SMS="inform.#.sms.#"; //声明交换机 @Bean(EXCHANGE_TOPICS_INFORM) public Exchange EXCHANGE_TOPICS_INFORM()&#123; //durable(true) 持久化，mq重启之后交换机还在 return ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(true).build(); &#125; //声明QUEUE_INFORM_EMAIL队列 @Bean(QUEUE_INFORM_EMAIL) public Queue QUEUE_INFORM_EMAIL()&#123; return new Queue(QUEUE_INFORM_EMAIL); &#125; //声明QUEUE_INFORM_SMS队列 @Bean(QUEUE_INFORM_SMS) public Queue QUEUE_INFORM_SMS()&#123; return new Queue(QUEUE_INFORM_SMS); &#125; //ROUTINGKEY_EMAIL队列绑定交换机，指定routingKey @Bean public Binding BINDING_QUEUE_INFORM_EMAIL(@Qualifier(QUEUE_INFORM_EMAIL) Queue queue,@Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_EMAIL).noargs(); &#125; //ROUTINGKEY_SMS队列绑定交换机，指定routingKey @Bean public Binding BINDING_ROUTINGKEY_SMS(@Qualifier(QUEUE_INFORM_SMS) Queue queue,@Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_SMS).noargs(); &#125;&#125; 生产端 使用RabbitTemplate发送消息 1234567891011121314151617181920212223package com.xuecheng.test.rabbitmq;import com.xuecheng.test.rabbitmq.config.RabbitmqConfig;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@SpringBootTest@RunWith(SpringRunner.class)public class Producer05_topics_springboot &#123; @Autowired RabbitTemplate rabbitTemplate; @Test public void testSendByTopics()&#123; for (int i=0;i&lt;5;i++)&#123; String message = "sms email inform to user"+i; rabbitTemplate.convertAndSend(RabbitmqConfig.EXCHANGE_TOPICS_INFORM,"inform.sms.email",message); System.out.println("Send Message is:'" + message + "'"); &#125; &#125;&#125; 消费端 使用@RabbitListener注解监听队列 1234567891011121314151617181920package com.xuecheng.test.rabbitmq.mq;import com.rabbitmq.client.Channel;import com.xuecheng.test.rabbitmq.config.RabbitmqConfig;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class ReceiveHandler &#123; //监听email队列 @RabbitListener(queues = &#123;RabbitmqConfig.QUEUE_INFORM_EMAIL&#125;) public void receive_email(String msg,Message message,Channel channel)&#123; System.out.println(msg); &#125; //监听sms队列 @RabbitListener(queues = &#123;RabbitmqConfig.QUEUE_INFORM_SMS&#125;) public void receive_sms(String msg,Message message,Channel channel)&#123; System.out.println(msg); &#125;&#125; 参考:黑马]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap的key存储对象]]></title>
    <url>%2F2019%2F02%2F28%2FHashMap%E7%9A%84key%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[HashMap的key存储对象活不多说,上代码1234567891011121314151617181920212223242526272829303132public class Person &#123; private String name; private Integer age; public Person() &#123; &#125; public Person(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 测试类 123456789101112public class TestMap &#123; public static void main(String[] args) &#123; Map&lt;Person,Object&gt; map = new HashMap&lt;&gt;(); Person person = new Person("z",18); map.put(person,"20"); Person person1 = new Person("z",18); System.out.println(map.get(person1)); &#125;&#125;// null// 重写Person类的hashCode()方法和它的equals()方法之后 取得 20 因为Person对象没有重写hashCode()方法和它的equals()方法,所以取不到值 因此HashMap的key值要是为类对象则类必须要重写该类的hashCode()方法和它的equals()方法]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程与并发原理]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考:慕课网 synchronized的注意事项线程安全问题的主要诱因 存在共享数据(也称临界资源) 存在多条线程共同操作这些共享数据 解决问题的根本方法: ​ 同一时刻有且只有一个线程在操作共享数据,其他线程必须等到该线程处理完数据后再对共享数据进行操作 互斥锁的特性 互斥性: 即在同一时间只允许一个线程持有某个对象锁,通过这种特性来实现多线程的协调机制,这样在同一时间只有一个线程对需要同步的代码块(复合操作)进行访问.互斥性也称为操作的原子性 可见性: 必须确保在锁被释放之前,对共享变量所做的修改,对于随后获得该锁的另一个线程是可见的(即在获得锁时应获得最新共享变量的值),否则另一个线程可能是在本地缓存的某个副本上继续操作,从而引起不一致 注意: synchronized 锁的不是代码,锁的都是对象 对象锁和类锁的总结 有线程访问对象的同步代码块时,另外的线程可以访问该对象的非同步代码块 若锁住的是同一个对象,一个线程在访问对象的同步代码块时,另一个访问对象的同步代码块的线程会被阻塞 若锁住的是同一个对象,一个线程在访问对象的同步方法时,另一个访问对象同步方法的线程会被阻塞 若锁住的是同一个对象,一个线程在访问对象的同步代码块时,另一个访问对象同步方法的线程会被阻塞,反之亦然 同一个类的不同对象的对象锁互不干扰 类锁由于也是一种特殊的对象锁,因此表现和上述1,2,3,4一致,而由于一个类只有一把对象锁,所以同一个类的不同对象使用类锁将会是同步的 类锁和对象锁互不干扰 自旋锁与自适应自旋锁自旋锁 许多情况下,共享数据的锁定状态持续时间较短,切换线程不值得 通过让线程执行忙循环等待锁的释放,不让出CPU 缺点: 若锁被其他线程长时间占用,会带来许多性能上的开销 自适应自旋锁 自旋的次数不再固定 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 锁消除 JIT编译时,对运行上下文进行扫描,去除不可能存在竞争的锁 锁粗化 通过扩大加锁的范围,避免反复加锁和解锁 synchronized的四种状态 锁膨胀方向: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁 偏向锁 大多数情况下,锁不存在多线程竞争,总是由同一线程多次获得 缺点: 不适用于锁竞争比较激烈的多线程场合 核心思想: ​ 如果一个线程获得了锁,那么锁就进入偏向模式,此时 Mark Word 的结构也变为偏向锁结构,当该线程再次请求锁时,无需再做任何同步操作,即获取锁的过程只需要检查 Mark Word 的锁标记位为偏向锁以及当前线程 Id 等于 Mark Word 的 ThreadId 即可,这样就省去了大量有关锁申请的操作 轻量级锁轻量级锁是由偏向锁升级来的,偏向锁运行在一个线程进入同步快的情况下,当第二个线程加入锁争用的时候,偏向锁就会升级为轻量级锁 适应的场景: 线程交替执行同步快 若存在同一时间访问同一锁的情况,就会导致轻量级锁膨胀为重量级锁 锁 优点 缺点 使用场景 偏向锁 加锁和解锁不需要CAS操作,没有额外的性能消耗,和执行非同步方法相比仅存在纳秒级的差距 如果线程间存在锁竞争,会带来额外的锁撤销的消耗 同一个线程访问同步块或者同步方法的场景 轻量级锁 竞争的线程不会阻塞,提高了响应速度 若线程长时间抢不到锁,自旋会消耗CPU性能 线程交替执行同步块或者同步方法的场景 重量级锁 线程竞争不适用自旋,不会消耗CPU 线程阻塞,响应时间缓慢,在多线程下,频繁的获取释放锁,会带来巨大的性能消耗 追求吞吐量,同步块或者同步方法执行时间较长的场景 volatile和synchronized的区别 volatile本质是告诉JVM当前变量在寄存器(工作内存)中的值是不确定的,需要从内存中读取;synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住直到该线程完成变量操作为止 volatile仅能使用在变量级别;synchronized则可以使用在变量,方法和类级别 volatile仅能实现变量的修改可见性,不能保证原子性;而synchronized则可以保证变量修改的可见性和原子性 volatile不会造成线程的阻塞;synchronized可能会造成线程的阻塞 volatile标记的变量不会被编译器优化;synchronized标记的变量可以被编译器优化 synchronized和ReentrantLook的区别 synchronized是关键字, ReentrantLook是类 ReentrantLook 可以对获取锁的等待时间进行设置,避免死锁 ReentrantLock 可以获取各种锁的信息 ReentrantLock 可以灵活的实现多路通知 机制: sync 操作 Mark Word, lock 调用 Unsafe 类的 park() 方法 happens-before 的八大原则 程序次序原则 : 一个线程内,按照代码顺序,书写在前面的操作先行发生于书写在后面的操作; 锁定规则 : 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作; volatile 变量规则 : 对一个变量的写操作先行发生于后面对这个变量的读操作; 传递规则 : 如果操作A先行发生于操作B, 而操作B又先行发生于操作C, 则可以得出操作A先行发生于操作C 线程启动规则 : Thread 对象的 start() 方法先行发生于此线程的每一个动作; 线程中断规则 : 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生; 线程终结规则 : 线程中所有的操作都先行发生于线程的终止检测,我们可以通过 Thread.join() 方法结束, Thread.isAlive() 的返回值手段检测到线程已经终止执行; 对象终结规则 : 一个对象的初始化完成先行发生于它的 finalize() 方法的开始; volatile 的作用 保证被 volatile 修饰的共享变量对所有线程总是可见的 禁止指令重排序优化 volatile 和 synchronized 的区别 volatile 本质是在告诉JVM当前变量在寄存器(工作内存)中的值是不确定的,需要从主存中读取;synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住直到该线程完成变量操作为止 volatile 仅能使用在变量级别; synchronized 则可以使用在变量,方法和类级别 volatile 仅能实现变量的修改可见性,不能保证原子性;而synchronized则可以保证变量修改的可见性和原子性 volatile 不会造成线程的阻塞;synchronized可能会造成线程的阻塞 volatile标记的变量不会被编译器优化;synchronized 标记的变量可以被编译器优化 未完待续…]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程与并发]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[参考:慕课网 Thred中 start 和 run 方法的区别 调用 start() 方法会创建一个新的子线程并启动 run() 方法只是 Thread 的一个普通方法的调用 Thread 和 Runnable 是什么关系 Thread 是实现了 Runnable 接口的类,使得 run 支持多线程 因为 java 的单一继承原则,推荐多使用 Runnable 接口 如何实现处理线程的返回值 主线程等待法(让主线程循环等待返回值) 使用 Thread 类的 join() 方法阻塞当前线程以等待子线程处理完毕 通过 Callable 接口实现 : 通过 FutureTask 或 线程池获取 通过 FutureTask 实现线程返回值例子如下: 123456789101112131415161718192021222324252627282930public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; String value = "test"; System.out.println("Ready to work"); Thread.currentThread().sleep(5000); System.out.println("Task down"); return value; &#125;&#125;public class FutureTaskDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyCallable()); // FutureTask 实现 RunnableFuture,RunnableFuture 继承 Runnable, Future new Thread(task).start(); if(!task.isDone()) &#123; System.out.println("task is not finished"); &#125; System.out.println("task return: " + task.get()); &#125;&#125;// 控制台输出// task is not finished// Ready to work// 5秒后// Task down// task return: test 通过线程池实现线程返回值例子如下: 12345678910111213141516171819public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; ExecutorService threadPool = Executors.newCachedThreadPool(); Future&lt;String&gt; future = threadPool.submit(new MyCallable()); if(!future.isDone()) &#123; System.out.println("task is not finished"); &#125; try &#123; System.out.println("task return: " + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭线程池 threadPool.shutdown(); &#125; &#125;&#125;// 返回结果跟上面一样 线程的状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public enum State &#123; /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; &#125; 新建(New) : 创建后尚未启动的线程的状态 运行(Runnable) : 包含 Runnable 和 Ready 无限期等待(Waiting) : 不会被分配 CPU 执行时间,需要显式被唤醒 限期等待(Timed_Waiting) : 在一定时间后会由系统自动唤醒 阻塞(Blocked) : 等待获取排它锁 结束(Terminated) : 已终止线程的状态,线程已经结束执行 sleep和wait的区别基本区别 sleep 是 Thread 类的方法, wait 是 Object 类中定义的方法 sleep() 方法可以在任何地方使用 wait() 方法只能在 synchronized 方法或 synchronized 块中使用 本质区别 Thread.sleep() 只会让出 CPU , 不会导致锁行为的改变 Object.wait() 不仅让出 CPU , 还会释放已经占有的同步资源锁 锁池和等待池 锁池(EntryList) ​ 假设线程 A 已经拥有了某个对象(不是类)的锁,而其它线程 B 和 C 想要调用这个对象的某个 synchronized 方法 (或者块) , 由于 B 和 C 线程在进入对象的某个 synchronized 方法 (或者块) , 由于 B 和 C 线程在进入对象 synchronized 方法之前必须获取到该对象锁的拥有权,而恰巧该对象的锁目前正在被线程 A 所占用,此时 B 和 C 线程就会被阻塞,进入一个地方去等待锁的释放,这个地方便是该对象的锁池 等待池(WaitSet) ​ 假设线程 A 调用了某个对象的 wait() 方法,线程 A 就会释放该对象的锁, 同时线程 A 就进入到了该对象的等待池中,进入到等待池中的线程不会去竞争该对象的锁 yield()方法当调用 Thread.yield() 方法时,会给线程调度器一个当前线程愿意让出 CPU 使用的暗示, 但是线程调度器可能会忽略这个暗示 如何中断线程调用 interrupt() , 通知线程应该中断了(与yield类似) 如果线程处于被阻塞状态, 那么线程将立即退出被阻塞状态,并抛出一个 InterruptedException 异常 如果线程处于正常活动状态,那么会将该线程的中断标志设置为 true, 被设置中断标志的线程将继续正常运行, 不受影响 总结]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis扩展]]></title>
    <url>%2F2019%2F02%2F19%2FRedis%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[参考:掘金 如何通过Redis实现分布式锁分布式锁需要解决的问题 互斥性 (只能有一个客户端获取到锁) 安全性 (每个客户端只能解自己的锁) 死锁 (某个客户端因某些原因宕机,无法释放锁,其它客户端无法获取到锁,从而形成死锁) 实现SETNX key value : 如果key不存在,则创建并赋值 时间复杂度 : O(1) 返回值 : 设置成功,返回1,设置失败,返回0 如何解决SETNX长期有效的问题EXPIRE key seconds 设置key的生存时间,当key过期时(生存时间为0),会被自动删除 缺点 : 原子性得不到满足,例子如下 使用以上两条命令来实现分布式锁,伪代码如下: 1234567RedisService redisService = SpringUtils.getBean(RedisService.calss);long status = redisService.setnx(key,"1");if(status == 1) &#123; redisService.expire(key,expire); // do something&#125; 上面代码会出现一些问题,如果程序中setnx后程序挂掉了,来不及执行expire方法,此时key因为没有设置过期时间,就会一直被占用着 SET key value [EX seconds] [PX milliseconds] [NX|XX] (满足原子性需求) EX second : 设置键的过期时间为 second 秒 PX milliseconds : 设置键的过期时间为 milliseconds 毫秒 NX : 只有键不存在时,才对键进行设置操作 XX : 只在键已经存在时,才对键进行设置操作 SET 操作成功完成时,返回ok,否则返回nil 使用上述命令伪代码如下: 12345RedisService redisService = SpringUtils.getBean(RedisService.class);String result = redisService.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);if ("ok".equals(result)) &#123; // do something&#125; 这样就可以保证分布式锁的原子性了 大量的 key 同时过期的注意事项集中过期,由于清除大量的key很耗时,会出现短暂的卡顿现象解决方案如下 解决方案 : 在设置key的过期时间的时候,给每个key的过期时间加上随机值 从海量Key里查询出某一固定前缀的KeyKEYS pattern : 查找所有符合给定模式pattern的key KEYS指令一次性 返回所有匹配的key 键的数量过大会使服务卡顿 举例: 1keys k1* // 此时如果数据量过大,可能会卡住 SCAN cursor [MATCH pattern] [COUNT count] 基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代,直到命令返回游标0完成一次遍历 不保证每次执行都返回某个给定数量的元素,支持模糊查询 一次返回的数量不可控,只能是大概率符合count参数 举例: 1scan 0 match k1 count 10 // 开始迭代,返回以k1为前缀的key,一次返回10条,下一次执行时把0换成上一次执行返回的游标即可,有可能会发生返回的key重复的现象,我们可以把返回的key存入到hashset里面,从而起到去重的效果 如何使用Redis做异步队列使用List作为队列,Rpush生产消息,Lpop消费消息 缺点 : 没有等待队列里有值就直接消费 弥补 : 可以通过在应用层引入 Sleep 机制去调用 Lpop 重试 BLPOP key [key …] timeout : 阻塞,直到队列有消息或者超时例子如下: 123blpop testlist 30// 此时消费者会等待生产者提供消息(在30秒有效时间内),如果有消息,消费者就会消费该消息// 使用 Blpop 可以代替 Sleep ,做到更好的消费消息 缺点 : 只能供一个消费者消费,解决办法:使用 pub/sub 模式 pub/sub : 主题订阅者模式(实现一对多) 发送者(pub)发送消息,订阅者(sub)消费消息 订阅者可以订阅任意数量的频道(Topic) 缺点 : 消息的发布是无状态的,无法保证可达,解决方案:使用专业的mq Redis如何做持久化RDB(快照)持久化:保存某个时间点的全量数据快照​ 在redis.conf文件中save 900 1 :这代表在900秒内有一条记录有写入指令就触发一次持久化 ​ stop-writes-on-bgsave-error yes :这代表当备份进程出错的时候,主进程就停止写入新的数据,这为了保证持久化的数据一致性的问题 缺点 内存数据的全量同步,数据量大会由于I/O而严重影响性能 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据 AOF (Append-Only-File) 持久化 : 保存写状态 记录下除了查询以外的所有变更数据库状态的指令 以append的形式追加保存到AOF文件中 RDB和AOF的优缺点 RDB优点 : 全量数据快照,文件小,恢复快 RDB缺点 : 无法保存最近一次快照之后的数据 AOF优点 : 可读性高,适合保存增量数据,数据不易丢失 AOF缺点 : 文件体积大,恢复时间长 RDB-AOF混合持久化方式(推荐) BGSAVE做镜像全量持久化,AOF做增量持久化 使用 Pipeline (管道)的好处 Pipeline和Linux的管道类似 Redis基于请求/响应模型,单个请求处理需要一一应答 Pipeline批量执行指令,节省多次IO往返的时间 有顺序依赖的指令建议分批发送]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构]]></title>
    <url>%2F2019%2F02%2F11%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[参考:掘金 What is the Redis? Redis 是互联网技术领域使用最为广泛的存储中间件，它是「Remote Dictionary Service」的首字母缩写，也就是「远程字典服务」。Redis 以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。国内外很多大型互联网公司都在使用 Redis，比如 Twitter、YouPorn、暴雪娱乐、Github、StackOverflow、腾讯、阿里、京东、华为、新浪微博等等，很多中小型公司也都有应用。也可以说，对 Redis 的了解和应用实践已成为当下中高级后端开发者绕不开的必备技能。 Redis 安装关于安装Redis这里不再赘述,可以使用网页版的 Web Redis 直接体验。 Redis 的数据结构Redis 有 5 种数据类型，分别为：string（字符串）、list（列表）、set（集合）、hash（哈希）和 zset（有序集合），熟练掌握这5种基本数据结构的使用时 Redis 知识最基础也是最重要的部分。 string （字符串）string 字符串是 Redis 最简单的数据结构，Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一的 key 值来获取相应的数据，不同类型的数据结构的差异就在于value的结构不一样。 字符串结构使用非常广泛，一个常见的用途就是缓存用户信息，我们将用户信息结构体使JSON序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。 Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度len。当字符串小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。 键值对12345678910&gt; set name codeholeOK&gt; get name&quot;codehole&quot;&gt; exists name(integer) 1&gt; del name(integer) 1&gt; get name(nil) 批量键值对可以批量对多个字符串进行读写，节省网络耗时开销。 12345678910111213&gt; set name1 codeholeOK&gt; set name2 holycoderOK&gt; mget name1 name2 name3 # 返回一个列表1) &quot;codehole&quot;2) &quot;holycoder&quot;3) (nil)&gt; mset name1 boy name2 girl name3 unknown&gt; mget name1 name2 name31) &quot;boy&quot;2) &quot;girl&quot;3) &quot;unknown&quot; 过期和 set 命令扩展可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的实效时间。 1234567891011121314151617181920212223&gt; set name codehole&gt; get name&quot;codehole&quot;&gt; expire name 5 # 5s 后过期... # wait for 5s&gt; get name(nil)&gt; setex name 5 codehole # 5s 后过期，等价于 set+expire&gt; get name&quot;codehole&quot;... # wait for 5s&gt; get name(nil)&gt; setnx name codehole # 如果 name 不存在就执行 set 创建(integer) 1&gt; get name&quot;codehole&quot;&gt; setnx name holycoder(integer) 0 # 因为 name 已经存在，所以 set 创建不成功&gt; get name&quot;codehole&quot; # 没有改变 计数如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值， Redis会报错。 123456789101112&gt; set age 30OK&gt; incr age(integer) 31&gt; incrby age 5(integer) 36&gt; incrby age -5(integer) 31&gt; set codehole 9223372036854775807 # Long.MaxOK&gt; incr codehole(error) ERR increment or decrement would overflow 字符串是由多个字节组成，每个字节又是由8个bit组成，如此就可以将一个字符串看成很多 bit 的组合，这便是 bitmap 【位图】数据结构（这块我也不太懂）。 list （列表）Redis 的列表相当于 Java 中的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢，时间复杂度为 O(n)。 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。 Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。 右边进左边出： 队列123456789101112&gt; rpush books python java golang(integer) 3&gt; llen books(integer) 3&gt; lpop books&quot;python&quot;&gt; lpop books&quot;java&quot;&gt; lpop books&quot;golang&quot;&gt; lpop books(nil) 右边进右边出：栈12345678910&gt; rpush books python java golang(integer) 3&gt; rpop books&quot;golang&quot;&gt; rpop books&quot;java&quot;&gt; rpop books&quot;python&quot;&gt; rpop books(nil) 慢操作index 相当于 Java 链表的 get(index) 方法，它需要对链表进行遍历，性能随着参数 index 增大 而变差。 ltrim 跟的两个参数 start_index 和 end_index 定义了一个区间，在这个区间内的值，ltrim要保留，区间之外统统砍掉。我们通过ltrim来实现一个定长的链表，这一点很有用。 index 可以为负数， index=-1 表示倒数第一个元素，同样 index=-2 则表示倒数第二个元素。 1234567891011121314151617&gt; rpush books python java golang(integer) 3&gt; lindex books 1 # O(n) 慎用&quot;java&quot;&gt; lrange books 0 -1 # 获取所有元素，O(n) 慎用1) &quot;python&quot;2) &quot;java&quot;3) &quot;golang&quot;&gt; ltrim books 1 -1 # O(n) 慎用OK&gt; lrange books 0 -11) &quot;java&quot;2) &quot;golang&quot;&gt; ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负OK&gt; llen books(integer) 0 快速列表如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 LinkedList，而是称之为快速链表 QuickList 的一个结构。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist ，也是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist 。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next 。所以 Redis 将链表和 ziplist 结合起来组成了 quicklist 。也就是将多个 ziplist 使用双向指针串起来使用，这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 hash（字典）Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串联起来。 不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。 渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。 当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。 hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。 hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。 1234567891011121314151617181920212223&gt; hset books java &quot;think in java&quot; # 命令行的字符串如果包含空格，要用引号括起来(integer) 1&gt; hset books golang &quot;concurrency in go&quot;(integer) 1&gt; hset books python &quot;python cookbook&quot;(integer) 1&gt; hgetall books # entries()，key 和 value 间隔出现1) &quot;java&quot;2) &quot;think in java&quot;3) &quot;golang&quot;4) &quot;concurrency in go&quot;5) &quot;python&quot;6) &quot;python cookbook&quot;&gt; hlen books(integer) 3&gt; hget books java&quot;think in java&quot;&gt; hset books golang &quot;learning go programming&quot; # 因为是更新操作，所以返回 0(integer) 0&gt; hget books golang&quot;learning go programming&quot;&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot; # 批量 setOK 同字符串一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 hincrby ，和 incr 使用基本一样。 123# 老钱又老了一岁&gt; hincrby user-zjh age 1(integer) 30 set（集合）Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL 。 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。 123456789101112131415161718&gt; sadd books python(integer) 1&gt; sadd books python # 重复(integer) 0&gt; sadd books java golang(integer) 2&gt; smembers books # 注意顺序，和插入的并不一致，因为 set 是无序的1) &quot;java&quot;2) &quot;python&quot;3) &quot;golang&quot;&gt; sismember books java # 查询某个 value 是否存在，相当于 contains(o)(integer) 1&gt; sismember books rust(integer) 0&gt; scard books # 获取长度相当于 count()(integer) 3&gt; spop books # 弹出一个&quot;java&quot; zset（有序列表）zset 可能是 Redis 提供的最为特色的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。 zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。 zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。 123456789101112131415161718192021222324252627282930313233&gt; zadd books 9.0 &quot;think in java&quot;(integer) 1&gt; zadd books 8.9 &quot;java concurrency&quot;(integer) 1&gt; zadd books 8.6 &quot;java cookbook&quot;(integer) 1&gt; zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围1) &quot;java cookbook&quot;2) &quot;java concurrency&quot;3) &quot;think in java&quot;&gt; zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围1) &quot;think in java&quot;2) &quot;java concurrency&quot;3) &quot;java cookbook&quot;&gt; zcard books # 相当于 count()(integer) 3&gt; zscore books &quot;java concurrency&quot; # 获取指定 value 的 score&quot;8.9000000000000004&quot; # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题&gt; zrank books &quot;java concurrency&quot; # 排名(integer) 1&gt; zrangebyscore books 0 8.91 # 根据分值区间遍历 zset1) &quot;java cookbook&quot;2) &quot;java concurrency&quot;&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。1) &quot;java cookbook&quot;2) &quot;8.5999999999999996&quot;3) &quot;java concurrency&quot;4) &quot;8.9000000000000004&quot;&gt; zrem books &quot;java concurrency&quot; # 删除 value(integer) 1&gt; zrange books 0 -11) &quot;java cookbook&quot;2) &quot;think in java&quot; 跳跃列表zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。 因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。 我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？ 想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。 跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。 想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。 「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。 定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？ 跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。 首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。 这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。 容器型数据结构的通用规则list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则： create if not exists 如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。 drop if no elements 如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。 过期时间Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。 还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。 12345678910&gt; set codehole yoyoOK&gt; expire codehole 600(integer) 1&gt; ttl codehole(integer) 597&gt; set codehole yoyoOK&gt; ttl codehole(integer) -1]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2F2019%2F01%2F30%2FMarkdown%2F</url>
    <content type="text"><![CDATA[初学Markdown,以此文章记录一下Markdown的语法. What is the Markdown ? Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。&lt;摘自百度百科&gt; Markdowm语法一、标题Markdown的标题是由 #开头 + 空格 + 标题组成(如上面的标题),一级标题用# ,二级标题用## ,以此类推,共六级标题. 12345678​``` [注意: #后面一定要加 空格 ]# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题​``` [注意: #后面一定要加 空格] 效果如下: 一级标题二级标题三级标题四级标题五级标题六级标题 二、字体 加粗 在需要加粗的文字左右用两个*包裹起来 斜体 在需要倾斜的文字左右用一个 * 包裹起来 斜体加粗 在需要倾斜和加粗的文字左右用三个 * 包裹起来 删除线 在需要加删除线的文字左右用两个 ~~ 包裹起来 例子: 1234**加粗***斜体****斜体加粗***~~删除线~~ 效果: 加粗 斜体 斜体加粗 删除线 三、引用语法: 在引用的文字前加&gt;,引用可以嵌套,如: 两个&gt;&gt; 三个&gt;&gt;&gt;,效果一样 实例: 123&gt;引用1&gt;&gt; 引用2&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用n 效果: 引用1 引用2 引用n 四、分割线使用三个或者三个以上的 - 或者 * 都可以 实例: 1234-------********* 效果: 五、图片语法: 123![图片alt](图片地址 &quot;图片title&quot;)图片alt: 显示在图片下方的文字,大多用于对图片的解释图片title: 图片的标题,当鼠标移动到图片上时显示的内容,title可有可无 实例: 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下: 六、超链接语法: 12[超链接名(超链接地址 &quot;超链接title&quot;)]title可有可无 示例: 12[百度](http://baidu.com)[QQ](http://qq.com) 效果: 百度 QQ 七、列表 无序列表 语法: 无序列表用 - + * 中任何一种都可以 实例: 1234- 列表+ 列表* 列表注意: - + * 后面必须有空格 效果: 列表 列表 列表 有序列表 语法: 数字加. 示例: 1231.列表2.列表3.列表 效果: 1.列表 2.列表 3.列表 列表嵌套 上一级和下一级之间有三个空格 一级无序列表 二级无序列表 二级无序列表 二级无序列表 八、 表格 语法: 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分隔表头和内容- 有一个就行,为了对齐,多加了几个文字默认居左- 两边加: 表示文字居中- 右边加: 表示文字居右注意: 原生的语法两边都要用 | 包起来 实例: 12345姓名(默认居左)|技能(设置为居中)|排行(设置为居右)--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下: 姓名(默认居左) 技能(设置为居中) 排行(设置为居右) 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 博客参考: https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
