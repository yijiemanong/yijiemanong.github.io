<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F19%2FRedis%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[如何通过Redis实现分布式锁分布式锁需要解决的问题 互斥性 (只能有一个客户端获取到锁) 安全性 (每个客户端只能解自己的锁) 死锁 (某个客户端因某些原因宕机,无法释放锁,其它客户端无法获取到锁,从而形成死锁) 实现SETNX key value : 如果key不存在,则创建并赋值 时间复杂度 : O(1) 返回值 : 设置成功,返回1,设置失败,返回0 如何解决SETNX长期有效的问题EXPIRE key seconds 设置key的生存时间,当key过期时(生存时间为0),会被自动删除 缺点 : 原子性得不到满足,例子如下 使用以上两条命令来实现分布式锁,伪代码如下: 1234567RedisService redisService = SpringUtils.getBean(RedisService.calss);long status = redisService.setnx(key,"1");if(status == 1) &#123; redisService.expire(key,expire); // do something&#125; 上面代码会出现一些问题,如果程序中setnx后程序挂掉了,来不及执行expire方法,此时key因为没有设置过期时间,就会一直被占用着 SET key value [EX seconds] [PX milliseconds] [NX|XX] (满足原子性需求) EX second : 设置键的过期时间为 second 秒 PX milliseconds : 设置键的过期时间为 milliseconds 毫秒 NX : 只有键不存在时,才对键进行设置操作 XX : 只在键已经存在时,才对键进行设置操作 SET 操作成功完成时,返回ok,否则返回nil 使用上述命令伪代码如下: 12345RedisService redisService = SpringUtils.getBean(RedisService.class);String result = redisService.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);if ("ok".equals(result)) &#123; // do something&#125; 这样就可以保证分布式锁的原子性了 大量的 key 同时过期的注意事项集中过期,由于清除大量的key很耗时,会出现短暂的卡顿现象解决方案如下 解决方案 : 在设置key的过期时间的时候,给每个key的过期时间加上随机值 从海量Key里查询出某一固定前缀的KeyKEYS pattern : 查找所有符合给定模式pattern的key KEYS指令一次性 返回所有匹配的key 键的数量过大会使服务卡顿 举例: 1keys k1* // 此时如果数据量过大,可能会卡住 SCAN cursor [MATCH pattern] [COUNT count] 基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代,直到命令返回游标0完成一次遍历 不保证每次执行都返回某个给定数量的元素,支持模糊查询 一次返回的数量不可控,只能是大概率符合count参数 举例: 1scan 0 match k1 count 10 // 开始迭代,返回以k1为前缀的key,一次返回10条,下一次执行时把0换成上一次执行返回的游标即可,有可能会发生返回的key重复的现象,我们可以把返回的key存入到hashset里面,从而起到去重的效果 如何使用Redis做异步队列使用List作为队列,Rpush生产消息,Lpop消费消息 缺点 : 没有等待队列里有值就直接消费 弥补 : 可以通过在应用层引入 Sleep 机制去调用 Lpop 重试 BLPOP key [key …] timeout : 阻塞,直到队列有消息或者超时例子如下: 123blpop testlist 30// 此时消费者会等待生产者提供消息(在30秒有效时间内),如果有消息,消费者就会消费该消息// 使用 Blpop 可以代替 Sleep ,做到更好的消费消息 缺点 : 只能供一个消费者消费,解决办法:使用 pub/sub 模式 pub/sub : 主题订阅者模式(实现一对多) 发送者(pub)发送消息,订阅者(sub)消费消息 订阅者可以订阅任意数量的频道(Topic) 缺点 : 消息的发布是无状态的,无法保证可达,解决方案:使用专业的mq Redis如何做持久化RDB(快照)持久化:保存某个时间点的全量数据快照​ 在redis.conf文件中save 900 1 :这代表在900秒内有一条记录有写入指令就触发一次持久化 ​ stop-writes-on-bgsave-error yes :这代表当备份进程出错的时候,主进程就停止写入新的数据,这为了保证持久化的数据一致性的问题 缺点 内存数据的全量同步,数据量大会由于I/O而严重影响性能 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据 AOF (Append-Only-File) 持久化 : 保存写状态 记录下除了查询以外的所有变更数据库状态的指令 以append的形式追加保存到AOF文件中 RDB和AOF的优缺点 RDB优点 : 全量数据快照,文件小,恢复快 RDB缺点 : 无法保存最近一次快照之后的数据 AOF优点 : 可读性高,适合保存增量数据,数据不易丢失 AOF缺点 : 文件体积大,恢复时间长 RDB-AOF混合持久化方式(推荐) BGSAVE做镜像全量持久化,AOF做增量持久化 使用 Pipeline (管道)的好处 Pipeline和Linux的管道类似 Redis基于请求/响应模型,单个请求处理需要一一应答 Pipeline批量执行指令,节省多次IO往返的时间 有顺序依赖的指令建议分批发送]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构]]></title>
    <url>%2F2019%2F02%2F11%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[谨以此文章记录一下Reids的使用。转自:https://juejin.im/post/5b53ee7e5188251aaa2d2e16 What is the Redis? Redis 是互联网技术领域使用最为广泛的存储中间件，它是「Remote Dictionary Service」的首字母缩写，也就是「远程字典服务」。Redis 以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。国内外很多大型互联网公司都在使用 Redis，比如 Twitter、YouPorn、暴雪娱乐、Github、StackOverflow、腾讯、阿里、京东、华为、新浪微博等等，很多中小型公司也都有应用。也可以说，对 Redis 的了解和应用实践已成为当下中高级后端开发者绕不开的必备技能。 Redis 安装关于安装Redis这里不再赘述,可以使用网页版的 Web Redis 直接体验。 Redis 的数据结构Redis 有 5 种数据类型，分别为：string（字符串）、list（列表）、set（集合）、hash（哈希）和 zset（有序集合），熟练掌握这5种基本数据结构的使用时 Redis 知识最基础也是最重要的部分。 string （字符串）string 字符串是 Redis 最简单的数据结构，Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一的 key 值来获取相应的数据，不同类型的数据结构的差异就在于value的结构不一样。 字符串结构使用非常广泛，一个常见的用途就是缓存用户信息，我们将用户信息结构体使JSON序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。 Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度len。当字符串小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。 键值对12345678910&gt; set name codeholeOK&gt; get name&quot;codehole&quot;&gt; exists name(integer) 1&gt; del name(integer) 1&gt; get name(nil) 批量键值对可以批量对多个字符串进行读写，节省网络耗时开销。 12345678910111213&gt; set name1 codeholeOK&gt; set name2 holycoderOK&gt; mget name1 name2 name3 # 返回一个列表1) &quot;codehole&quot;2) &quot;holycoder&quot;3) (nil)&gt; mset name1 boy name2 girl name3 unknown&gt; mget name1 name2 name31) &quot;boy&quot;2) &quot;girl&quot;3) &quot;unknown&quot; 过期和 set 命令扩展可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的实效时间。 1234567891011121314151617181920212223&gt; set name codehole&gt; get name&quot;codehole&quot;&gt; expire name 5 # 5s 后过期... # wait for 5s&gt; get name(nil)&gt; setex name 5 codehole # 5s 后过期，等价于 set+expire&gt; get name&quot;codehole&quot;... # wait for 5s&gt; get name(nil)&gt; setnx name codehole # 如果 name 不存在就执行 set 创建(integer) 1&gt; get name&quot;codehole&quot;&gt; setnx name holycoder(integer) 0 # 因为 name 已经存在，所以 set 创建不成功&gt; get name&quot;codehole&quot; # 没有改变 计数如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值， Redis会报错。 123456789101112&gt; set age 30OK&gt; incr age(integer) 31&gt; incrby age 5(integer) 36&gt; incrby age -5(integer) 31&gt; set codehole 9223372036854775807 # Long.MaxOK&gt; incr codehole(error) ERR increment or decrement would overflow 字符串是由多个字节组成，每个字节又是由8个bit组成，如此就可以将一个字符串看成很多 bit 的组合，这便是 bitmap 【位图】数据结构（这块我也不太懂）。 list （列表）Redis 的列表相当于 Java 中的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢，时间复杂度为 O(n)。 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。 Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。 右边进左边出： 队列123456789101112&gt; rpush books python java golang(integer) 3&gt; llen books(integer) 3&gt; lpop books&quot;python&quot;&gt; lpop books&quot;java&quot;&gt; lpop books&quot;golang&quot;&gt; lpop books(nil) 右边进右边出：栈12345678910&gt; rpush books python java golang(integer) 3&gt; rpop books&quot;golang&quot;&gt; rpop books&quot;java&quot;&gt; rpop books&quot;python&quot;&gt; rpop books(nil) 慢操作index 相当于 Java 链表的 get(index) 方法，它需要对链表进行遍历，性能随着参数 index 增大 而变差。 ltrim 跟的两个参数 start_index 和 end_index 定义了一个区间，在这个区间内的值，ltrim要保留，区间之外统统砍掉。我们通过ltrim来实现一个定长的链表，这一点很有用。 index 可以为负数， index=-1 表示倒数第一个元素，同样 index=-2 则表示倒数第二个元素。 1234567891011121314151617&gt; rpush books python java golang(integer) 3&gt; lindex books 1 # O(n) 慎用&quot;java&quot;&gt; lrange books 0 -1 # 获取所有元素，O(n) 慎用1) &quot;python&quot;2) &quot;java&quot;3) &quot;golang&quot;&gt; ltrim books 1 -1 # O(n) 慎用OK&gt; lrange books 0 -11) &quot;java&quot;2) &quot;golang&quot;&gt; ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负OK&gt; llen books(integer) 0 快速列表如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 LinkedList，而是称之为快速链表 QuickList 的一个结构。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist ，也是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist 。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next 。所以 Redis 将链表和 ziplist 结合起来组成了 quicklist 。也就是将多个 ziplist 使用双向指针串起来使用，这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 hash（字典）Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串联起来。 不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。 渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。 当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。 hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。 hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。 1234567891011121314151617181920212223&gt; hset books java &quot;think in java&quot; # 命令行的字符串如果包含空格，要用引号括起来(integer) 1&gt; hset books golang &quot;concurrency in go&quot;(integer) 1&gt; hset books python &quot;python cookbook&quot;(integer) 1&gt; hgetall books # entries()，key 和 value 间隔出现1) &quot;java&quot;2) &quot;think in java&quot;3) &quot;golang&quot;4) &quot;concurrency in go&quot;5) &quot;python&quot;6) &quot;python cookbook&quot;&gt; hlen books(integer) 3&gt; hget books java&quot;think in java&quot;&gt; hset books golang &quot;learning go programming&quot; # 因为是更新操作，所以返回 0(integer) 0&gt; hget books golang&quot;learning go programming&quot;&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot; # 批量 setOK 同字符串一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 hincrby ，和 incr 使用基本一样。 123# 老钱又老了一岁&gt; hincrby user-zjh age 1(integer) 30 set（集合）Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL 。 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。 123456789101112131415161718&gt; sadd books python(integer) 1&gt; sadd books python # 重复(integer) 0&gt; sadd books java golang(integer) 2&gt; smembers books # 注意顺序，和插入的并不一致，因为 set 是无序的1) &quot;java&quot;2) &quot;python&quot;3) &quot;golang&quot;&gt; sismember books java # 查询某个 value 是否存在，相当于 contains(o)(integer) 1&gt; sismember books rust(integer) 0&gt; scard books # 获取长度相当于 count()(integer) 3&gt; spop books # 弹出一个&quot;java&quot; zset（有序列表）zset 可能是 Redis 提供的最为特色的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。 zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。 zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。 123456789101112131415161718192021222324252627282930313233&gt; zadd books 9.0 &quot;think in java&quot;(integer) 1&gt; zadd books 8.9 &quot;java concurrency&quot;(integer) 1&gt; zadd books 8.6 &quot;java cookbook&quot;(integer) 1&gt; zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围1) &quot;java cookbook&quot;2) &quot;java concurrency&quot;3) &quot;think in java&quot;&gt; zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围1) &quot;think in java&quot;2) &quot;java concurrency&quot;3) &quot;java cookbook&quot;&gt; zcard books # 相当于 count()(integer) 3&gt; zscore books &quot;java concurrency&quot; # 获取指定 value 的 score&quot;8.9000000000000004&quot; # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题&gt; zrank books &quot;java concurrency&quot; # 排名(integer) 1&gt; zrangebyscore books 0 8.91 # 根据分值区间遍历 zset1) &quot;java cookbook&quot;2) &quot;java concurrency&quot;&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。1) &quot;java cookbook&quot;2) &quot;8.5999999999999996&quot;3) &quot;java concurrency&quot;4) &quot;8.9000000000000004&quot;&gt; zrem books &quot;java concurrency&quot; # 删除 value(integer) 1&gt; zrange books 0 -11) &quot;java cookbook&quot;2) &quot;think in java&quot; 跳跃列表zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。 因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。 我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？ 想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。 跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。 想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。 「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。 定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？ 跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。 首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。 这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。 容器型数据结构的通用规则list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则： create if not exists 如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。 drop if no elements 如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。 过期时间Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。 还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。 12345678910&gt; set codehole yoyoOK&gt; expire codehole 600(integer) 1&gt; ttl codehole(integer) 597&gt; set codehole yoyoOK&gt; ttl codehole(integer) -1]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2F2019%2F01%2F30%2FMarkdown%2F</url>
    <content type="text"><![CDATA[初学Markdown,以此文章记录一下Markdown的语法. What is the Markdown ? Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。&lt;摘自百度百科&gt; Markdowm语法一、标题Markdown的标题是由 #开头 + 空格 + 标题组成(如上面的标题),一级标题用# ,二级标题用## ,以此类推,共六级标题. 12345678​``` [注意: #后面一定要加 空格 ]# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题​``` [注意: #后面一定要加 空格] 效果如下: 一级标题二级标题三级标题四级标题五级标题六级标题 二、字体 加粗 在需要加粗的文字左右用两个*包裹起来 斜体 在需要倾斜的文字左右用一个 * 包裹起来 斜体加粗 在需要倾斜和加粗的文字左右用三个 * 包裹起来 删除线 在需要加删除线的文字左右用两个 ~~ 包裹起来 例子: 1234**加粗***斜体****斜体加粗***~~删除线~~ 效果: 加粗 斜体 斜体加粗 删除线 三、引用语法: 在引用的文字前加&gt;,引用可以嵌套,如: 两个&gt;&gt; 三个&gt;&gt;&gt;,效果一样 实例: 123&gt;引用1&gt;&gt; 引用2&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用n 效果: 引用1 引用2 引用n 四、分割线使用三个或者三个以上的 - 或者 * 都可以 实例: 1234-------********* 效果: 五、图片语法: 123![图片alt](图片地址 &quot;图片title&quot;)图片alt: 显示在图片下方的文字,大多用于对图片的解释图片title: 图片的标题,当鼠标移动到图片上时显示的内容,title可有可无 实例: 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下: 六、超链接语法: 12[超链接名(超链接地址 &quot;超链接title&quot;)]title可有可无 示例: 12[百度](http://baidu.com)[QQ](http://qq.com) 效果: 百度 QQ 七、列表 无序列表 语法: 无序列表用 - + * 中任何一种都可以 实例: 1234- 列表+ 列表* 列表注意: - + * 后面必须有空格 效果: 列表 列表 列表 有序列表 语法: 数字加. 示例: 1231.列表2.列表3.列表 效果: 1.列表 2.列表 3.列表 列表嵌套 上一级和下一级之间有三个空格 一级无序列表 二级无序列表 二级无序列表 二级无序列表 八、 表格 语法: 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分隔表头和内容- 有一个就行,为了对齐,多加了几个文字默认居左- 两边加: 表示文字居中- 右边加: 表示文字居右注意: 原生的语法两边都要用 | 包起来 实例: 12345姓名(默认居左)|技能(设置为居中)|排行(设置为居右)--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下: 姓名(默认居左) 技能(设置为居中) 排行(设置为居右) 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 博客参考: https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
