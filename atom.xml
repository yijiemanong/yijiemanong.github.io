<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Z</title>
  
  <subtitle>小码农</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-02T09:51:39.731Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zjh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ 研究</title>
    <link href="http://yoursite.com/2019/03/02/RabbitMQ%20%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2019/03/02/RabbitMQ 研究/</id>
    <published>2019-03-02T14:04:51.000Z</published>
    <updated>2019-03-02T09:51:39.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-研究"><a href="#RabbitMQ-研究" class="headerlink" title="RabbitMQ 研究"></a>RabbitMQ 研究</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。RabbitMQ官方地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p></blockquote><a id="more"></a><p>开发中消息队列通常有如下应用场景：</p><ol><li>任务异步处理。<br>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</li><li>应用程序解耦合<br>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</li></ol><h4 id="为什么使用RabbitMQ"><a href="#为什么使用RabbitMQ" class="headerlink" title="为什么使用RabbitMQ ?"></a>为什么使用RabbitMQ ?</h4><ol><li>使用简单,功能强大</li><li>基于AMQP协议</li><li>社区活跃,文档完善</li><li>高并发性能好,这主要得基于Erlang语言</li><li>Spring Boot 默认已集成 RabbitMQ</li></ol><h4 id="AMQP-是什么"><a href="#AMQP-是什么" class="headerlink" title="AMQP 是什么 ?"></a>AMQP 是什么 ?</h4><blockquote><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF/1619218" target="_blank" rel="noopener">消息</a>队列协议,是<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/4329788" target="_blank" rel="noopener">应用层</a>协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240" target="_blank" rel="noopener">中间件</a>不同产品，不同的开发语言等条件的限制。<a href="https://baike.baidu.com/item/Erlang" target="_blank" rel="noopener">Erlang</a>中的实现有 <a href="https://baike.baidu.com/item/RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a>等。—-&lt;百度百科&gt;</p></blockquote><p>总结 : </p><p>AMQP是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，<br>为的就是解决MQ市场上协议不统一的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务</p><h4 id="JMS是什么"><a href="#JMS是什么" class="headerlink" title="JMS是什么 ?"></a>JMS是什么 ?</h4><blockquote><p>JMS即<a href="https://baike.baidu.com/item/Java%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">Java消息服务</a>（Java Message Service）应用程序接口，是一个<a href="https://baike.baidu.com/item/Java%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/5899771" target="_blank" rel="noopener">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154" target="_blank" rel="noopener">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336" target="_blank" rel="noopener">分布式系统</a>中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。—–&lt;百度百科&gt;</p></blockquote><p>总结 :</p><p> JMS是java提供的一套消息服务API标准，其目的是为所有的java应用程序提供统一的消息通信的标准，类似java的jdbc，只要遵循jms标准的应用程序之间都可以进行消息通信。它和AMQP有什么 不同，jms是java语言专属的消息服务标准，它是在api层定义标准，并且只能用于java应用；而AMQP是在协议层定义的标准，是跨语言的 。</p><hr><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="RabbitMQ工作原理"><a href="#RabbitMQ工作原理" class="headerlink" title="RabbitMQ工作原理"></a>RabbitMQ工作原理</h4><p><img src="/2019/03/02/RabbitMQ 研究/RabbitMQ工作原理.png" alt="RabbitMQ工作原理"></p><hr><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>常用工作模式:</p><ol><li>Work queues</li><li>Publish/Subscribe</li><li>Routing</li><li>Topics</li><li>Header</li></ol><h4 id="Work-queues"><a href="#Work-queues" class="headerlink" title="Work queues"></a>Work queues</h4><p><img src="/2019/03/02/RabbitMQ 研究/1.png" alt="Work queues"></p><p>应用场景: 对于任务过重或任务较多情况使用工作队列模式可以提高任务处理的速度</p><h4 id="Publish-subscribe"><a href="#Publish-subscribe" class="headerlink" title="Publish/subscribe"></a>Publish/subscribe</h4><p>发布订阅模式：</p><ol><li>每个消费者监听自己的队列。</li><li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收<br>到消息。</li></ol><p><img src="/2019/03/02/RabbitMQ 研究/2.png" alt="Publish/subscribe"></p><h4 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h4><p>路由模式：</p><ol><li>每个消费者监听自己的队列，并且设置routingkey。</li><li>生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列。</li></ol><p><img src="/2019/03/02/RabbitMQ 研究/3.png" alt="Routing"></p><h4 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h4><p>与上面路由模式类似,可以使用通配符,规则如下:</p><ol><li>中间以“.”分隔</li><li>符号#可以匹配多个词，符号*可以匹配一个词语</li></ol><p><img src="/2019/03/02/RabbitMQ 研究/4.png" alt="Topics"></p><h4 id="Header模式"><a href="#Header模式" class="headerlink" title="Header模式"></a>Header模式</h4><p>header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配</p><h3 id="Spring整合RabbitMQ"><a href="#Spring整合RabbitMQ" class="headerlink" title="Spring整合RabbitMQ"></a>Spring整合RabbitMQ</h3><ol><li>使用spring-boot-starter-amqp会自动添加spring-rabbit依赖，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring‐boot‐starter‐amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring‐boot‐starter‐test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring‐boot‐starter‐logging&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>配置application.yml</p><p>配置连接 RabbitMQ 的参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">44000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test‐rabbitmq‐producer</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    virtualHost:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>定义RabbitConfig类,配置Exchange, Queue, 及绑定交换机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.test.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-06-17 20:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="string">"queue_inform_email"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_INFORM_SMS = <span class="string">"queue_inform_sms"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_TOPICS_INFORM=<span class="string">"exchange_topics_inform"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTINGKEY_EMAIL=<span class="string">"inform.#.email.#"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTINGKEY_SMS=<span class="string">"inform.#.sms.#"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span>(EXCHANGE_TOPICS_INFORM)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">EXCHANGE_TOPICS_INFORM</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//durable(true) 持久化，mq重启之后交换机还在</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(<span class="keyword">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明QUEUE_INFORM_EMAIL队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(QUEUE_INFORM_EMAIL)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">QUEUE_INFORM_EMAIL</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_INFORM_EMAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明QUEUE_INFORM_SMS队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(QUEUE_INFORM_SMS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">QUEUE_INFORM_SMS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_INFORM_SMS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ROUTINGKEY_EMAIL队列绑定交换机，指定routingKey</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">BINDING_QUEUE_INFORM_EMAIL</span><span class="params">(@Qualifier(QUEUE_INFORM_EMAIL)</span> Queue queue,@<span class="title">Qualifier</span><span class="params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_EMAIL).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ROUTINGKEY_SMS队列绑定交换机，指定routingKey</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">BINDING_ROUTINGKEY_SMS</span><span class="params">(@Qualifier(QUEUE_INFORM_SMS)</span> Queue queue,@<span class="title">Qualifier</span><span class="params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">           BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_SMS).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>生产端</p><p>使用RabbitTemplate发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.test.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.test.rabbitmq.config.RabbitmqConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer05_topics_springboot</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendByTopics</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">String message = <span class="string">"sms email inform to user"</span>+i;</span><br><span class="line">rabbitTemplate.convertAndSend(RabbitmqConfig.EXCHANGE_TOPICS_INFORM,<span class="string">"inform.sms.email"</span>,message);</span><br><span class="line">System.out.println(<span class="string">"Send Message is:'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>消费端</p><p>使用@RabbitListener注解监听队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.test.rabbitmq.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.test.rabbitmq.config.RabbitmqConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//监听email队列</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = &#123;RabbitmqConfig.QUEUE_INFORM_EMAIL&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive_email</span><span class="params">(String msg,Message message,Channel channel)</span></span>&#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听sms队列</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = &#123;RabbitmqConfig.QUEUE_INFORM_SMS&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive_sms</span><span class="params">(String msg,Message message,Channel channel)</span></span>&#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考:<a href="http://www.itheima.com/special/hmjavaeezly/?jingjia-01-heima-pinpaici-pc-heima" target="_blank" rel="noopener">黑马</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-研究&quot;&gt;&lt;a href=&quot;#RabbitMQ-研究&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 研究&quot;&gt;&lt;/a&gt;RabbitMQ 研究&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。RabbitMQ官方地址：&lt;a href=&quot;http://www.rabbitmq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的key存储对象</title>
    <link href="http://yoursite.com/2019/02/28/HashMap%E7%9A%84key%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/02/28/HashMap的key存储对象/</id>
    <published>2019-02-28T14:50:51.000Z</published>
    <updated>2019-02-28T10:43:01.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap的key存储对象"><a href="#HashMap的key存储对象" class="headerlink" title="HashMap的key存储对象"></a>HashMap的key存储对象</h3><p>活不多说,上代码<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"z"</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(person,<span class="string">"20"</span>);</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"z"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(map.get(person1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 重写Person类的hashCode()方法和它的equals()方法之后 取得 20</span></span><br></pre></td></tr></table></figure><p>因为Person对象没有重写hashCode()方法和它的equals()方法,所以取不到值</p><p>因此HashMap的key值要是为类对象则类必须要重写该类的<strong>hashCode()方法</strong>和它的<strong>equals()方法</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap的key存储对象&quot;&gt;&lt;a href=&quot;#HashMap的key存储对象&quot; class=&quot;headerlink&quot; title=&quot;HashMap的key存储对象&quot;&gt;&lt;/a&gt;HashMap的key存储对象&lt;/h3&gt;&lt;p&gt;活不多说,上代码&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>多线程与并发原理</title>
    <link href="http://yoursite.com/2019/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/23/多线程与并发原理/</id>
    <published>2019-02-23T14:50:51.000Z</published>
    <updated>2019-02-28T10:47:18.146Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考:<a href="https://coding.imooc.com/class/303.html" target="_blank" rel="noopener">慕课网</a></p></blockquote><h3 id="synchronized的注意事项"><a href="#synchronized的注意事项" class="headerlink" title="synchronized的注意事项"></a>synchronized的注意事项</h3><h4 id="线程安全问题的主要诱因"><a href="#线程安全问题的主要诱因" class="headerlink" title="线程安全问题的主要诱因"></a>线程安全问题的主要诱因</h4><ul><li>存在<strong>共享数据</strong>(也称临界资源)</li><li>存在多条线程共同操作这些<strong>共享数据</strong></li></ul><p><strong>解决问题的根本方法</strong>:</p><p>​    同一时刻有且只有一个线程在操作共享数据,其他线程必须等到该线程处理完数据后再对共享数据进行操作</p><a id="more"></a><h4 id="互斥锁的特性"><a href="#互斥锁的特性" class="headerlink" title="互斥锁的特性"></a>互斥锁的特性</h4><ul><li>互斥性: 即在同一时间只允许一个线程持有某个对象锁,通过这种特性来实现多线程的协调机制,这样在同一时间只有一个线程对需要同步的代码块(复合操作)进行访问.互斥性也称为操作的原子性</li><li>可见性: 必须确保在锁被释放之前,对共享变量所做的修改,对于随后获得该锁的另一个线程是可见的(即在获得锁时应获得最新共享变量的值),否则另一个线程可能是在本地缓存的某个副本上继续操作,从而引起不一致</li></ul><p>注意: synchronized 锁的不是代码,锁的都是对象</p><h4 id="对象锁和类锁的总结"><a href="#对象锁和类锁的总结" class="headerlink" title="对象锁和类锁的总结"></a>对象锁和类锁的总结</h4><ul><li><p>有线程访问对象的<code>同步代码块</code>时,另外的线程可以访问该对象的<code>非同步代码块</code></p></li><li><p>若锁住的是同一个对象,一个线程在访问对象的<code>同步代码块</code>时,另一个访问对象的<code>同步代码块</code>的线程会被阻塞</p></li><li><p>若锁住的是同一个对象,一个线程在访问对象的<code>同步方法</code>时,另一个访问对象<code>同步方法</code>的线程会被阻塞</p></li><li><p>若锁住的是同一个对象,一个线程在访问对象的<code>同步代码块</code>时,另一个访问对象<code>同步方法</code>的线程会被阻塞,反之亦然</p></li><li><p>同一个类的不同对象的对象锁互不干扰</p></li><li><p>类锁由于也是一种特殊的对象锁,因此表现和上述1,2,3,4一致,而由于一个类只有一把对象锁,所以同一个类的不同对象使用类锁将会是同步的</p></li><li><p>类锁和对象锁互不干扰</p></li></ul><hr><h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul><li>许多情况下,共享数据的锁定状态持续时间较短,切换线程不值得</li><li>通过让线程执行忙循环等待锁的释放,不让出CPU</li><li>缺点: 若锁被其他线程长时间占用,会带来许多性能上的开销</li></ul><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><ul><li>自旋的次数不再固定</li><li>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><ul><li>JIT编译时,对运行上下文进行扫描,去除不可能存在竞争的锁</li></ul><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><ul><li>通过扩大加锁的范围,避免反复加锁和解锁</li></ul><hr><h3 id="synchronized的四种状态"><a href="#synchronized的四种状态" class="headerlink" title="synchronized的四种状态"></a>synchronized的四种状态</h3><ul><li>锁膨胀方向: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><ul><li>大多数情况下,锁不存在多线程竞争,总是由同一线程多次获得</li><li>缺点: 不适用于锁竞争比较激烈的多线程场合</li></ul><p><strong>核心思想:</strong></p><p>​    如果一个线程获得了锁,那么锁就进入偏向模式,此时 Mark Word 的结构也变为偏向锁结构,当该线程再次请求锁时,无需再做任何同步操作,即获取锁的过程只需要检查 Mark Word 的锁标记位为偏向锁以及当前线程 Id 等于 Mark Word 的 ThreadId 即可,这样就省去了大量有关锁申请的操作</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是由偏向锁升级来的,偏向锁运行在一个线程进入同步快的情况下,当第二个线程加入锁争用的时候,偏向锁就会升级为轻量级锁</p><p>适应的场景: 线程交替执行同步快</p><p>若存在同一时间访问同一锁的情况,就会导致轻量级锁膨胀为重量级锁</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要CAS操作,没有额外的性能消耗,和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争,会带来额外的锁撤销的消耗</td><td>同一个线程访问同步块或者同步方法的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞,提高了响应速度</td><td>若线程长时间抢不到锁,自旋会消耗CPU性能</td><td>线程交替执行同步块或者同步方法的场景</td></tr><tr><td>重量级锁</td><td>线程竞争不适用自旋,不会消耗CPU</td><td>线程阻塞,响应时间缓慢,在多线程下,频繁的获取释放锁,会带来巨大的性能消耗</td><td>追求吞吐量,同步块或者同步方法执行时间较长的场景</td></tr></tbody></table><hr><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ul><li><p>volatile本质是告诉JVM当前变量在寄存器(工作内存)中的值是不确定的,需要从内存中读取;synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住直到该线程完成变量操作为止</p></li><li><p>volatile仅能使用在变量级别;synchronized则可以使用在变量,方法和类级别</p></li><li><p>volatile仅能实现变量的修改可见性,不能保证原子性;而synchronized则可以保证变量修改的可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞;synchronized可能会造成线程的阻塞</p></li><li><p>volatile标记的变量不会被编译器优化;synchronized标记的变量可以被编译器优化</p></li></ul><hr><h3 id="synchronized和ReentrantLook的区别"><a href="#synchronized和ReentrantLook的区别" class="headerlink" title="synchronized和ReentrantLook的区别"></a>synchronized和ReentrantLook的区别</h3><ul><li><p>synchronized是关键字, ReentrantLook是类</p></li><li><p>ReentrantLook 可以对获取锁的等待时间进行设置,避免死锁</p></li><li><p>ReentrantLock 可以获取各种锁的信息</p></li><li><p>ReentrantLock 可以灵活的实现多路通知</p></li><li><p>机制: sync 操作 Mark Word, lock 调用 Unsafe 类的 park() 方法</p></li></ul><hr><h3 id="happens-before-的八大原则"><a href="#happens-before-的八大原则" class="headerlink" title="happens-before 的八大原则"></a>happens-before 的八大原则</h3><ol><li>程序次序原则 : 一个线程内,按照代码顺序,书写在前面的操作先行发生于书写在后面的操作;</li><li>锁定规则 : 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作;</li><li>volatile 变量规则 : 对一个变量的写操作先行发生于后面对这个变量的读操作;</li><li>传递规则 : 如果操作A先行发生于操作B, 而操作B又先行发生于操作C, 则可以得出操作A先行发生于操作C</li><li>线程启动规则 : Thread 对象的 start() 方法先行发生于此线程的每一个动作;</li><li>线程中断规则 : 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li><li>线程终结规则 : 线程中所有的操作都先行发生于线程的终止检测,我们可以通过 Thread.join() 方法结束, Thread.isAlive() 的返回值手段检测到线程已经终止执行;</li><li>对象终结规则 : 一个对象的初始化完成先行发生于它的 finalize() 方法的开始;</li></ol><h3 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h3><ul><li>保证被 volatile 修饰的共享变量对所有线程总是可见的</li><li>禁止指令重排序优化</li></ul><h3 id="volatile-和-synchronized-的区别"><a href="#volatile-和-synchronized-的区别" class="headerlink" title="volatile 和 synchronized 的区别"></a>volatile 和 synchronized 的区别</h3><ul><li>volatile 本质是在告诉JVM当前变量在寄存器(工作内存)中的值是不确定的,需要从主存中读取;synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住直到该线程完成变量操作为止</li><li>volatile 仅能使用在变量级别; synchronized 则可以使用在变量,方法和类级别</li><li>volatile 仅能实现变量的修改可见性,不能保证原子性;而synchronized则可以保证变量修改的可见性和原子性</li><li>volatile 不会造成线程的阻塞;synchronized可能会造成线程的阻塞</li><li>volatile标记的变量不会被编译器优化;synchronized 标记的变量可以被编译器优化</li></ul><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考:&lt;a href=&quot;https://coding.imooc.com/class/303.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;synchronized的注意事项&quot;&gt;&lt;a href=&quot;#synchronized的注意事项&quot; class=&quot;headerlink&quot; title=&quot;synchronized的注意事项&quot;&gt;&lt;/a&gt;synchronized的注意事项&lt;/h3&gt;&lt;h4 id=&quot;线程安全问题的主要诱因&quot;&gt;&lt;a href=&quot;#线程安全问题的主要诱因&quot; class=&quot;headerlink&quot; title=&quot;线程安全问题的主要诱因&quot;&gt;&lt;/a&gt;线程安全问题的主要诱因&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;存在&lt;strong&gt;共享数据&lt;/strong&gt;(也称临界资源)&lt;/li&gt;
&lt;li&gt;存在多条线程共同操作这些&lt;strong&gt;共享数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决问题的根本方法&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;​    同一时刻有且只有一个线程在操作共享数据,其他线程必须等到该线程处理完数据后再对共享数据进行操作&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>多线程与并发</title>
    <link href="http://yoursite.com/2019/02/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2019/02/21/多线程与并发/</id>
    <published>2019-02-21T14:04:51.000Z</published>
    <updated>2019-02-28T10:47:02.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考:<a href="https://coding.imooc.com/class/303.html" target="_blank" rel="noopener">慕课网</a></p></blockquote><h3 id="Thred中-start-和-run-方法的区别"><a href="#Thred中-start-和-run-方法的区别" class="headerlink" title="Thred中 start 和 run 方法的区别"></a>Thred中 start 和 run 方法的区别</h3><ul><li><p>调用 start() 方法会创建一个新的子线程并启动</p></li><li><p>run() 方法只是 Thread 的一个普通方法的调用</p></li></ul><hr><a id="more"></a><h3 id="Thread-和-Runnable-是什么关系"><a href="#Thread-和-Runnable-是什么关系" class="headerlink" title="Thread 和 Runnable 是什么关系"></a>Thread 和 Runnable 是什么关系</h3><ul><li>Thread 是实现了 Runnable 接口的类,使得 run 支持多线程</li><li>因为 java 的单一继承原则,推荐多使用 Runnable 接口</li></ul><hr><h3 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h3><ul><li>主线程等待法(让主线程循环等待返回值)</li><li>使用 Thread 类的 join() 方法阻塞当前线程以等待子线程处理完毕</li><li><p>通过 Callable 接口实现 : 通过 FutureTask 或 线程池获取</p><p> 通过 FutureTask 实现线程返回值例子如下:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">"test"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Ready to work"</span>);</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"Task down"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        <span class="comment">// FutureTask 实现 RunnableFuture,RunnableFuture 继承 Runnable, Future</span></span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="keyword">if</span>(!task.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"task is not finished"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"task return: "</span> + task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line"><span class="comment">// task is not finished</span></span><br><span class="line"><span class="comment">// Ready to work</span></span><br><span class="line"><span class="comment">// 5秒后</span></span><br><span class="line"><span class="comment">// Task down</span></span><br><span class="line"><span class="comment">// task return: test</span></span><br></pre></td></tr></table></figure><p>  通过线程池实现线程返回值例子如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        <span class="keyword">if</span>(!future.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"task is not finished"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"task return: "</span> + future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回结果跟上面一样</span></span><br></pre></td></tr></table></figure><hr><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block/method or</span><br><span class="line">         * reenter a synchronized block/method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>新建(New) : 创建后尚未启动的线程的状态</li><li>运行(Runnable) : 包含 Runnable 和 Ready</li><li>无限期等待(Waiting) : 不会被分配 CPU 执行时间,需要显式被唤醒</li><li>限期等待(Timed_Waiting) : 在一定时间后会由系统自动唤醒</li><li>阻塞(Blocked) : 等待获取排它锁</li><li>结束(Terminated) : 已终止线程的状态,线程已经结束执行</li></ul><hr><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><h4 id="基本区别"><a href="#基本区别" class="headerlink" title="基本区别"></a>基本区别</h4><ul><li>sleep 是 Thread 类的方法, wait 是 Object 类中定义的方法</li><li>sleep() 方法可以在任何地方使用</li><li>wait() 方法只能在 synchronized 方法或 synchronized 块中使用</li></ul><h4 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h4><ul><li><p>Thread.sleep() 只会让出 CPU , 不会导致锁行为的改变</p></li><li><p>Object.wait() 不仅让出 CPU , 还会释放已经占有的同步资源锁</p></li></ul><hr><h3 id="锁池和等待池"><a href="#锁池和等待池" class="headerlink" title="锁池和等待池"></a>锁池和等待池</h3><ul><li><p>锁池(EntryList)</p><p>​    假设线程 A 已经拥有了某个对象(不是类)的锁,而其它线程 B 和 C 想要调用这个对象的某个 synchronized 方法 (或者块) , 由于 B 和 C 线程在进入对象的某个 synchronized 方法 (或者块) , 由于 B 和 C 线程在进入对象 synchronized 方法之前必须获取到该对象锁的拥有权,而恰巧该对象的锁目前正在被线程 A 所占用,此时 B 和 C 线程就会被阻塞,进入一个地方去等待锁的释放,这个地方便是该对象的锁池</p></li><li><p>等待池(WaitSet)</p><p>​    假设线程 A 调用了某个对象的 wait() 方法,线程 A 就会释放该对象的锁, 同时线程 A 就进入到了该对象的等待池中,进入到等待池中的线程不会去竞争该对象的锁</p></li></ul><hr><h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>当调用 Thread.yield() 方法时,会给线程调度器一个当前线程愿意让出 CPU 使用的暗示, 但是线程调度器可能会忽略这个暗示</p><hr><h3 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h3><p>调用 interrupt() , 通知线程应该中断了(与yield类似)</p><ol><li>如果线程处于被阻塞状态, 那么线程将立即退出被阻塞状态,并抛出一个 InterruptedException 异常</li><li>如果线程处于正常活动状态,那么会将该线程的中断标志设置为 true, 被设置中断标志的线程将继续正常运行, 不受影响</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2019/02/21/多线程与并发/1.jpg" alt="线程状态切换"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考:&lt;a href=&quot;https://coding.imooc.com/class/303.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Thred中-start-和-run-方法的区别&quot;&gt;&lt;a href=&quot;#Thred中-start-和-run-方法的区别&quot; class=&quot;headerlink&quot; title=&quot;Thred中 start 和 run 方法的区别&quot;&gt;&lt;/a&gt;Thred中 start 和 run 方法的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用 start() 方法会创建一个新的子线程并启动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;run() 方法只是 Thread 的一个普通方法的调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis扩展</title>
    <link href="http://yoursite.com/2019/02/19/Redis%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2019/02/19/Redis扩展/</id>
    <published>2019-02-19T14:54:20.000Z</published>
    <updated>2019-02-28T10:46:18.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考:<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527" target="_blank" rel="noopener">掘金</a></p></blockquote><h3 id="如何通过Redis实现分布式锁"><a href="#如何通过Redis实现分布式锁" class="headerlink" title="如何通过Redis实现分布式锁"></a>如何通过Redis实现分布式锁</h3><h4 id="分布式锁需要解决的问题"><a href="#分布式锁需要解决的问题" class="headerlink" title="分布式锁需要解决的问题"></a>分布式锁需要解决的问题</h4><ul><li>互斥性 (只能有一个客户端获取到锁)</li><li>安全性 (每个客户端只能解自己的锁)</li><li>死锁 (某个客户端因某些原因宕机,无法释放锁,其它客户端无法获取到锁,从而形成死锁)</li></ul><a id="more"></a><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="SETNX-key-value-如果key不存在-则创建并赋值"><a href="#SETNX-key-value-如果key不存在-则创建并赋值" class="headerlink" title="SETNX key value : 如果key不存在,则创建并赋值"></a>SETNX key value : 如果key不存在,则创建并赋值</h5><ul><li>时间复杂度 : O(1)</li><li>返回值 : 设置成功,<code>返回1</code>,设置失败,<code>返回0</code></li></ul><h6 id="如何解决SETNX长期有效的问题"><a href="#如何解决SETNX长期有效的问题" class="headerlink" title="如何解决SETNX长期有效的问题"></a>如何解决SETNX长期有效的问题</h6><p><strong>EXPIRE key seconds</strong></p><ul><li><p>设置key的生存时间,当key过期时(生存时间为0),会被自动删除</p></li><li><p>缺点 : <code>原子性</code>得不到满足,例子如下</p><p>使用以上两条命令来实现分布式锁,伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RedisService redisService = SpringUtils.getBean(RedisService.calss);</span><br><span class="line"><span class="keyword">long</span> status = redisService.setnx(key,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(status == <span class="number">1</span>) &#123;</span><br><span class="line">    redisService.expire(key,expire);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会出现一些问题,如果程序中<code>setnx</code>后程序挂掉了,来不及执行<code>expire</code>方法,此时key因为没有设置过期时间,就会一直被占用着</p></li></ul><h5 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX-满足原子性需求"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX-满足原子性需求" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]  (满足原子性需求)"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]  (满足原子性需求)</h5><ul><li><strong>EX second : 设置键的过期时间为 second 秒</strong></li><li><strong>PX milliseconds :  设置键的过期时间为 milliseconds 毫秒</strong> </li><li><strong>NX : 只有键不存在时,才对键进行设置操作</strong></li><li><strong>XX : 只在键已经存在时,才对键进行设置操作</strong></li><li><strong>SET 操作成功完成时,返回<code>ok</code>,否则返回<code>nil</code></strong></li></ul><p>使用上述命令伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RedisService redisService = SpringUtils.getBean(RedisService.class);</span><br><span class="line">String result = redisService.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"ok"</span>.equals(result)) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以保证分布式锁的原子性了</p><h4 id="大量的-key-同时过期的注意事项"><a href="#大量的-key-同时过期的注意事项" class="headerlink" title="大量的 key 同时过期的注意事项"></a>大量的 key 同时过期的注意事项</h4><p><strong>集中过期,由于清除大量的key很耗时,会出现短暂的卡顿现象解决方案如下</strong></p><p>解决方案 : 在设置key的过期时间的时候,给每个key的过期时间加上随机值</p><hr><h3 id="从海量Key里查询出某一固定前缀的Key"><a href="#从海量Key里查询出某一固定前缀的Key" class="headerlink" title="从海量Key里查询出某一固定前缀的Key"></a>从海量Key里查询出某一固定前缀的Key</h3><h4 id="KEYS-pattern-查找所有符合给定模式pattern的key"><a href="#KEYS-pattern-查找所有符合给定模式pattern的key" class="headerlink" title="KEYS pattern : 查找所有符合给定模式pattern的key"></a>KEYS pattern : 查找所有符合给定模式pattern的key</h4><ul><li>KEYS指令<strong><code>一次性</code> </strong>返回所有匹配的key</li><li>键的数量过大会使服务卡顿</li></ul><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys k1* // 此时如果数据量过大,可能会卡住</span><br></pre></td></tr></table></figure><h4 id="SCAN-cursor-MATCH-pattern-COUNT-count"><a href="#SCAN-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SCAN cursor [MATCH pattern] [COUNT count]"></a>SCAN cursor [MATCH pattern] [COUNT count]</h4><ul><li>基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程</li><li>以0作为游标开始一次新的迭代,直到命令返回游标0完成一次遍历</li><li>不保证每次执行都返回某个给定数量的元素,支持模糊查询</li><li>一次返回的数量不可控,只能是大概率符合count参数</li></ul><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan 0 match k1 count 10 // 开始迭代,返回以k1为前缀的key,一次返回10条,下一次执行时把0换成上一次执行返回的游标即可,有可能会发生返回的key重复的现象,我们可以把返回的key存入到hashset里面,从而起到去重的效果</span><br></pre></td></tr></table></figure><hr><h3 id="如何使用Redis做异步队列"><a href="#如何使用Redis做异步队列" class="headerlink" title="如何使用Redis做异步队列"></a>如何使用Redis做异步队列</h3><h4 id="使用List作为队列-Rpush生产消息-Lpop消费消息"><a href="#使用List作为队列-Rpush生产消息-Lpop消费消息" class="headerlink" title="使用List作为队列,Rpush生产消息,Lpop消费消息"></a>使用List作为队列,Rpush生产消息,Lpop消费消息</h4><ul><li>缺点 : 没有等待队列里有值就直接消费</li><li>弥补 : 可以通过在应用层引入 Sleep 机制去调用 Lpop 重试</li></ul><h4 id="BLPOP-key-key-…-timeout-阻塞-直到队列有消息或者超时"><a href="#BLPOP-key-key-…-timeout-阻塞-直到队列有消息或者超时" class="headerlink" title="BLPOP key [key …] timeout : 阻塞,直到队列有消息或者超时"></a>BLPOP key [key …] timeout : 阻塞,直到队列有消息或者超时</h4><p>例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop testlist 30</span><br><span class="line">// 此时消费者会等待生产者提供消息(在30秒有效时间内),如果有消息,消费者就会消费该消息</span><br><span class="line">// 使用 Blpop 可以代替 Sleep ,做到更好的消费消息</span><br></pre></td></tr></table></figure><ul><li>缺点 : 只能供一个消费者消费,解决办法:使用 pub/sub 模式</li></ul><h4 id="pub-sub-主题订阅者模式-实现一对多"><a href="#pub-sub-主题订阅者模式-实现一对多" class="headerlink" title="pub/sub : 主题订阅者模式(实现一对多)"></a>pub/sub : 主题订阅者模式(实现一对多)</h4><ul><li>发送者(pub)发送消息,订阅者(sub)消费消息</li><li>订阅者可以订阅任意数量的频道(Topic)</li><li>缺点 : 消息的发布是无状态的,无法保证可达,解决方案:使用专业的mq</li></ul><hr><h3 id="Redis如何做持久化"><a href="#Redis如何做持久化" class="headerlink" title="Redis如何做持久化"></a>Redis如何做持久化</h3><h4 id="RDB-快照-持久化-保存某个时间点的全量数据快照"><a href="#RDB-快照-持久化-保存某个时间点的全量数据快照" class="headerlink" title="RDB(快照)持久化:保存某个时间点的全量数据快照"></a>RDB(快照)持久化:保存某个时间点的全量数据快照</h4><p>​    在redis.conf文件中save 900 1 :这代表在900秒内有一条记录有写入指令就触发一次持久化</p><p>​    stop-writes-on-bgsave-error yes :这代表当备份进程出错的时候,主进程就停止写入新的数据,这为了保证持久化的数据一致性的问题</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>内存数据的全量同步,数据量大会由于I/O而严重影响性能</li><li>可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据</li></ul><h4 id="AOF-Append-Only-File-持久化-保存写状态"><a href="#AOF-Append-Only-File-持久化-保存写状态" class="headerlink" title="AOF (Append-Only-File) 持久化 : 保存写状态"></a>AOF (Append-Only-File) 持久化 : 保存写状态</h4><ul><li><p>记录下除了查询以外的所有变更数据库状态的指令</p></li><li><p>以append的形式追加保存到AOF文件中</p></li></ul><h4 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h4><ul><li>RDB优点 : 全量数据快照,文件小,恢复快</li><li>RDB缺点 : 无法保存最近一次快照之后的数据</li><li>AOF优点 : 可读性高,适合保存增量数据,数据不易丢失</li><li>AOF缺点 : 文件体积大,恢复时间长</li></ul><h4 id="RDB-AOF混合持久化方式-推荐"><a href="#RDB-AOF混合持久化方式-推荐" class="headerlink" title="RDB-AOF混合持久化方式(推荐)"></a>RDB-AOF混合持久化方式(推荐)</h4><ul><li>BGSAVE做镜像全量持久化,AOF做增量持久化</li></ul><hr><h3 id="使用-Pipeline-管道-的好处"><a href="#使用-Pipeline-管道-的好处" class="headerlink" title="使用 Pipeline (管道)的好处"></a>使用 Pipeline (管道)的好处</h3><ul><li>Pipeline和Linux的管道类似</li><li>Redis基于请求/响应模型,单个请求处理需要一一应答</li><li>Pipeline批量执行指令,节省多次IO往返的时间</li><li>有顺序依赖的指令建议分批发送</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考:&lt;a href=&quot;https://juejin.im/book/5afc2e5f6fb9a07a9b362527&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;如何通过Redis实现分布式锁&quot;&gt;&lt;a href=&quot;#如何通过Redis实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;如何通过Redis实现分布式锁&quot;&gt;&lt;/a&gt;如何通过Redis实现分布式锁&lt;/h3&gt;&lt;h4 id=&quot;分布式锁需要解决的问题&quot;&gt;&lt;a href=&quot;#分布式锁需要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;分布式锁需要解决的问题&quot;&gt;&lt;/a&gt;分布式锁需要解决的问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;互斥性 (只能有一个客户端获取到锁)&lt;/li&gt;
&lt;li&gt;安全性 (每个客户端只能解自己的锁)&lt;/li&gt;
&lt;li&gt;死锁 (某个客户端因某些原因宕机,无法释放锁,其它客户端无法获取到锁,从而形成死锁)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构</title>
    <link href="http://yoursite.com/2019/02/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/02/11/Redis数据结构/</id>
    <published>2019-02-11T11:29:07.000Z</published>
    <updated>2019-02-28T10:52:42.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考:<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527" target="_blank" rel="noopener">掘金</a></p></blockquote><h3 id="What-is-the-Redis"><a href="#What-is-the-Redis" class="headerlink" title="What is the Redis?"></a>What is the Redis?</h3><blockquote><p>Redis 是互联网技术领域使用最为广泛的存储中间件，它是「<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice」的首字母缩写，也就是「远程字典服务」。Redis 以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。国内外很多大型互联网公司都在使用 Redis，比如 Twitter、YouPorn、暴雪娱乐、Github、StackOverflow、腾讯、阿里、京东、华为、新浪微博等等，很多中小型公司也都有应用。也可以说，对 Redis 的了解和应用实践已成为当下中高级后端开发者绕不开的必备技能。</p></blockquote><a id="more"></a><h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><p>关于安装Redis这里不再赘述,可以使用网页版的 <a href="https://try.redis.io/" target="_blank" rel="noopener">Web Redis</a> 直接体验。</p><h3 id="Redis-的数据结构"><a href="#Redis-的数据结构" class="headerlink" title="Redis 的数据结构"></a>Redis 的数据结构</h3><p>Redis 有 5 种数据类型，分别为：string（字符串）、list（列表）、set（集合）、hash（哈希）和 zset（有序集合），熟练掌握这5种基本数据结构的使用时 Redis 知识最基础也是最重要的部分。</p><h4 id="string-（字符串）"><a href="#string-（字符串）" class="headerlink" title="string （字符串）"></a>string （字符串）</h4><p>string 字符串是 Redis 最简单的数据结构，Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一的 key 值来获取相应的数据，不同类型的数据结构的差异就在于value的结构不一样。</p><p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息，我们将用户信息结构体使JSON序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。</p><p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度len。当字符串小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p><h5 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">OK</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; exists name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h5 id="批量键值对"><a href="#批量键值对" class="headerlink" title="批量键值对"></a>批量键值对</h5><p>可以批量对多个字符串进行读写，节省网络耗时开销。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name1 codehole</span><br><span class="line">OK</span><br><span class="line">&gt; set name2 holycoder</span><br><span class="line">OK</span><br><span class="line">&gt; mget name1 name2 name3 # 返回一个列表</span><br><span class="line">1) &quot;codehole&quot;</span><br><span class="line">2) &quot;holycoder&quot;</span><br><span class="line">3) (nil)</span><br><span class="line">&gt; mset name1 boy name2 girl name3 unknown</span><br><span class="line">&gt; mget name1 name2 name3</span><br><span class="line">1) &quot;boy&quot;</span><br><span class="line">2) &quot;girl&quot;</span><br><span class="line">3) &quot;unknown&quot;</span><br></pre></td></tr></table></figure><h5 id="过期和-set-命令扩展"><a href="#过期和-set-命令扩展" class="headerlink" title="过期和 set 命令扩展"></a>过期和 set 命令扩展</h5><p>可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的实效时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; expire name 5 # 5s 后过期</span><br><span class="line">... # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setex name 5 codehole # 5s 后过期，等价于 set+expire</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">... # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setnx name codehole # 如果 name 不存在就执行 set 创建</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; setnx name holycoder</span><br><span class="line">(integer) 0 # 因为 name 已经存在，所以 set 创建不成功</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot; # 没有改变</span><br></pre></td></tr></table></figure><h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><p>如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值， Redis会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; set age 30</span><br><span class="line">OK</span><br><span class="line">&gt; incr age</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; incrby age 5</span><br><span class="line">(integer) 36</span><br><span class="line">&gt; incrby age -5</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; set codehole 9223372036854775807 # Long.Max</span><br><span class="line">OK</span><br><span class="line">&gt; incr codehole</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br></pre></td></tr></table></figure><p>字符串是由多个字节组成，每个字节又是由8个bit组成，如此就可以将一个字符串看成很多 bit 的组合，这便是 bitmap 【位图】数据结构（这块我也不太懂）。</p><h4 id="list-（列表）"><a href="#list-（列表）" class="headerlink" title="list （列表）"></a>list （列表）</h4><p>Redis 的列表相当于 Java 中的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p><p>当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p><h5 id="右边进左边出：-队列"><a href="#右边进左边出：-队列" class="headerlink" title="右边进左边出： 队列"></a>右边进左边出： 队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h5 id="右边进右边出：栈"><a href="#右边进右边出：栈" class="headerlink" title="右边进右边出：栈"></a>右边进右边出：栈</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h5 id="慢操作"><a href="#慢操作" class="headerlink" title="慢操作"></a>慢操作</h5><p>index 相当于 Java 链表的 <strong>get(index)</strong> 方法，它需要对链表进行遍历，性能随着参数 index <strong>增大</strong> 而变差。</p><p>ltrim 跟的两个参数 <strong>start_index</strong> 和 <strong>end_index</strong> 定义了一个区间，在这个区间内的值，ltrim要保留，区间之外统统砍掉。我们通过ltrim来实现一个定长的链表，这一点很有用。</p><p>index 可以为负数， <strong>index=-1</strong> 表示倒数第一个元素，同样 <strong>index=-2</strong> 则表示倒数第二个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lindex books 1 # O(n) 慎用</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lrange books 0 -1 # 获取所有元素，O(n) 慎用</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 -1 # O(n) 慎用</span><br><span class="line">OK</span><br><span class="line">&gt; lrange books 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负</span><br><span class="line">OK</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h5 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h5><p>如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 <strong>LinkedList</strong>，而是称之为快速链表 <strong>QuickList</strong> 的一个结构。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <strong>ziplist</strong> ，也是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 <strong>quicklist</strong> 。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 <strong>int</strong> 类型的数据，结构上还需要两个额外的指针 <strong>prev</strong> 和 <strong>next</strong> 。所以 Redis 将链表和 <strong>ziplist</strong> 结合起来组成了 <strong>quicklist</strong> 。也就是将多个    <strong>ziplist</strong> 使用双向指针串起来使用，这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h4 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a>hash（字典）</h4><p>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串联起来。</p><p>不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。</p><p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。</p><p>当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。</p><p>hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset books java &quot;think in java&quot; # 命令行的字符串如果包含空格，要用引号括起来</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books golang &quot;concurrency in go&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books python &quot;python cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hgetall books # entries()，key 和 value 间隔出现</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;concurrency in go&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;python cookbook&quot;</span><br><span class="line">&gt; hlen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; hget books java</span><br><span class="line">&quot;think in java&quot;</span><br><span class="line">&gt; hset books golang &quot;learning go programming&quot; # 因为是更新操作，所以返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; hget books golang</span><br><span class="line">&quot;learning go programming&quot;</span><br><span class="line">&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot; # 批量 set</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>同字符串一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 <strong>hincrby</strong> ，和 <strong>incr</strong> 使用基本一样。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 老钱又老了一岁</span><br><span class="line">&gt; hincrby user-zjh age 1</span><br><span class="line">(integer) 30</span><br></pre></td></tr></table></figure><h4 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h4><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 <strong>NULL</strong> 。</p><p>当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。</p><p>set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd books python</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd books python # 重复</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sadd books java golang</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; smembers books # 注意顺序，和插入的并不一致，因为 set 是无序的</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; sismember books java # 查询某个 value 是否存在，相当于 contains(o)</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember books rust</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; scard books # 获取长度相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; spop books # 弹出一个</span><br><span class="line">&quot;java&quot;</span><br></pre></td></tr></table></figure><h4 id="zset（有序列表）"><a href="#zset（有序列表）" class="headerlink" title="zset（有序列表）"></a>zset（有序列表）</h4><p>zset 可能是 Redis 提供的最为特色的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。</p><p>zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。</p><p>zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。</p><p>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd books 9.0 &quot;think in java&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.9 &quot;java concurrency&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.6 &quot;java cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;think in java&quot;</span><br><span class="line">&gt; zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围</span><br><span class="line">1) &quot;think in java&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;java cookbook&quot;</span><br><span class="line">&gt; zcard books # 相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; zscore books &quot;java concurrency&quot; # 获取指定 value 的 score</span><br><span class="line">&quot;8.9000000000000004&quot; # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class="line">&gt; zrank books &quot;java concurrency&quot; # 排名</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrangebyscore books 0 8.91 # 根据分值区间遍历 zset</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;8.5999999999999996&quot;</span><br><span class="line">3) &quot;java concurrency&quot;</span><br><span class="line">4) &quot;8.9000000000000004&quot;</span><br><span class="line">&gt; zrem books &quot;java concurrency&quot; # 删除 value</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br></pre></td></tr></table></figure><h5 id="跳跃列表"><a href="#跳跃列表" class="headerlink" title="跳跃列表"></a>跳跃列表</h5><p>zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。</p><p>因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。</p><p><img src="/2019/02/11/Redis数据结构/1.png" alt="3"></p><p>我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？</p><p>想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。</p><p>跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。</p><p>想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。</p><p>「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。</p><p>定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？</p><p>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。</p><p>首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p><p>这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。</p><h2 id="容器型数据结构的通用规则"><a href="#容器型数据结构的通用规则" class="headerlink" title="容器型数据结构的通用规则"></a>容器型数据结构的通用规则</h2><p>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：</p><ol><li><p>create if not exists</p><p>如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。</p></li><li><p>drop if no elements</p><p>如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。</p></li></ol><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。</p><p>还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; set codehole yoyo</span><br><span class="line">OK</span><br><span class="line">&gt; expire codehole 600</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ttl codehole</span><br><span class="line">(integer) 597</span><br><span class="line">&gt; set codehole yoyo</span><br><span class="line">OK</span><br><span class="line">&gt; ttl codehole</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考:&lt;a href=&quot;https://juejin.im/book/5afc2e5f6fb9a07a9b362527&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;What-is-the-Redis&quot;&gt;&lt;a href=&quot;#What-is-the-Redis&quot; class=&quot;headerlink&quot; title=&quot;What is the Redis?&quot;&gt;&lt;/a&gt;What is the Redis?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 是互联网技术领域使用最为广泛的存储中间件，它是「&lt;strong&gt;Re&lt;/strong&gt;mote &lt;strong&gt;Di&lt;/strong&gt;ctionary &lt;strong&gt;S&lt;/strong&gt;ervice」的首字母缩写，也就是「远程字典服务」。Redis 以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。国内外很多大型互联网公司都在使用 Redis，比如 Twitter、YouPorn、暴雪娱乐、Github、StackOverflow、腾讯、阿里、京东、华为、新浪微博等等，很多中小型公司也都有应用。也可以说，对 Redis 的了解和应用实践已成为当下中高级后端开发者绕不开的必备技能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法笔记</title>
    <link href="http://yoursite.com/2019/01/30/Markdown/"/>
    <id>http://yoursite.com/2019/01/30/Markdown/</id>
    <published>2019-01-30T08:16:58.000Z</published>
    <updated>2019-02-28T10:45:19.881Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>初学Markdown,以此文章记录一下Markdown的语法. </p></blockquote><h3 id="What-is-the-Markdown"><a href="#What-is-the-Markdown" class="headerlink" title="What is the Markdown ?"></a>What is the Markdown ?</h3><blockquote><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如<a href="https://baike.baidu.com/item/LaTeX" target="_blank" rel="noopener">LaTeX</a>，<a href="https://baike.baidu.com/item/Docbook" target="_blank" rel="noopener">Docbook</a>。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<a href="https://baike.baidu.com/item/Pandoc" target="_blank" rel="noopener">Pandoc</a>；要么基于网站，如<a href="https://baike.baidu.com/item/GitHub" target="_blank" rel="noopener">GitHub</a>和<a href="https://baike.baidu.com/item/Wikipedia" target="_blank" rel="noopener">Wikipedia</a>，在语法上基本兼容，但在一些语法和渲染效果上有改动。<br>&lt;摘自百度百科&gt;</p></blockquote><a id="more"></a><h3 id="Markdowm语法"><a href="#Markdowm语法" class="headerlink" title="Markdowm语法"></a>Markdowm语法</h3><h4 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h4><p>Markdown的标题是由 #开头 + 空格 + 标题组成(如上面的标题),一级标题用# ,二级标题用## ,以此类推,共六级标题.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​``` [注意: #后面一定要加 空格 ]</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">​``` [注意: #后面一定要加 空格]</span><br></pre></td></tr></table></figure><p>效果如下:</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h4 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h4><ul><li><p><strong>加粗</strong></p><p>在需要加粗的文字左右用<code>两个</code>*包裹起来</p></li><li><p><em>斜体</em></p><p>在需要倾斜的文字左右用<code>一个</code> * 包裹起来</p></li><li><p><strong><em>斜体加粗</em></strong></p><p>在需要倾斜和加粗的文字左右用<code>三个</code> * 包裹起来</p></li><li><p><del>删除线</del></p><p>在需要加删除线的文字左右用<code>两个</code> ~~ 包裹起来</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果:</p><p><strong>加粗</strong></p><p><em>斜体</em></p><p><strong><em>斜体加粗</em></strong></p><p><del>删除线</del></p><hr></li></ul><h4 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h4><p>语法: 在引用的文字前加&gt;,引用可以嵌套,如: 两个&gt;&gt; 三个&gt;&gt;&gt;,效果一样</p><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用1</span><br><span class="line">&gt;&gt; 引用2</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用n</span><br></pre></td></tr></table></figure><p>效果:</p><blockquote><p>引用1</p><blockquote><p>引用2</p><blockquote><blockquote><blockquote><blockquote><p>引用n</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><hr><h4 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h4><p>使用三个或者三个以上的 - 或者 * 都可以</p><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">******</span><br></pre></td></tr></table></figure><p>效果:</p><hr><hr><hr><hr><h4 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h4><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line">图片alt: 显示在图片下方的文字,大多用于对图片的解释</span><br><span class="line">图片title: 图片的标题,当鼠标移动到图片上时显示的内容,title可有可无</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</span><br><span class="line">u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;)</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg" alt="blockchain" title="区块链"></p><hr><h4 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h4><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名(超链接地址 &quot;超链接title&quot;)]</span><br><span class="line">title可有可无</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[百度](http://baidu.com)</span><br><span class="line">[QQ](http://qq.com)</span><br></pre></td></tr></table></figure><p>效果:</p><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><p><a href="http://qq.com" target="_blank" rel="noopener">QQ</a></p><hr><h4 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h4><ul><li><p>无序列表</p><p>语法: 无序列表用 - + * 中任何一种都可以</p><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 列表</span><br><span class="line">+ 列表</span><br><span class="line">* 列表</span><br><span class="line">注意: - + * 后面必须有空格</span><br></pre></td></tr></table></figure><p>效果:</p><ul><li><p>列表</p></li><li><p>列表</p></li><li><p>列表</p></li></ul></li><li><p>有序列表</p><p>语法: 数字加.</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.列表</span><br><span class="line">2.列表</span><br><span class="line">3.列表</span><br></pre></td></tr></table></figure><p>效果:</p><p>1.列表</p><p>2.列表</p><p>3.列表</p></li><li><p>列表嵌套</p><p>上一级和下一级之间有三个空格</p></li></ul><ul><li><p>一级无序列表</p><ul><li><p>二级无序列表</p></li><li><p>二级无序列表</p></li><li><p>二级无序列表</p></li></ul></li></ul><hr><h4 id="八、-表格"><a href="#八、-表格" class="headerlink" title="八、 表格"></a>八、 表格</h4><p>  语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分隔表头和内容</span><br><span class="line">- 有一个就行,为了对齐,多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">- 两边加: 表示文字居中</span><br><span class="line">- 右边加: 表示文字居右</span><br><span class="line">注意: 原生的语法两边都要用 | 包起来</span><br></pre></td></tr></table></figure><p>  实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名(默认居左)|技能(设置为居中)|排行(设置为居右)</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><p>效果如下:</p><table><thead><tr><th>姓名(默认居左)</th><th style="text-align:center">技能(设置为居中)</th><th style="text-align:right">排行(设置为居右)</th></tr></thead><tbody><tr><td>刘备</td><td style="text-align:center">哭</td><td style="text-align:right">大哥</td></tr><tr><td>关羽</td><td style="text-align:center">打</td><td style="text-align:right">二哥</td></tr><tr><td>张飞</td><td style="text-align:center">骂</td><td style="text-align:right">三弟</td></tr></tbody></table><p>博客参考: <a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;初学Markdown,以此文章记录一下Markdown的语法. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;What-is-the-Markdown&quot;&gt;&lt;a href=&quot;#What-is-the-Markdown&quot; class=&quot;headerlink&quot; title=&quot;What is the Markdown ?&quot;&gt;&lt;/a&gt;What is the Markdown ?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如&lt;a href=&quot;https://baike.baidu.com/item/LaTeX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LaTeX&lt;/a&gt;，&lt;a href=&quot;https://baike.baidu.com/item/Docbook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docbook&lt;/a&gt;。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如&lt;a href=&quot;https://baike.baidu.com/item/Pandoc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pandoc&lt;/a&gt;；要么基于网站，如&lt;a href=&quot;https://baike.baidu.com/item/GitHub&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/Wikipedia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wikipedia&lt;/a&gt;，在语法上基本兼容，但在一些语法和渲染效果上有改动。&lt;br&gt;&amp;lt;摘自百度百科&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
